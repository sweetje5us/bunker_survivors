<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Bunker Survivors</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
      /* Загружаем кастомные шрифты для советского стиля */
      @font-face {
        font-family: 'pobeda-regular';
        src: url('src/fonts/pobeda-regular.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      
      @font-face {
        font-family: '28 Days Later Cyr Regular';
        src: url('src/fonts/28 Days Later Cyr Regular.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      
      @font-face {
        font-family: 'Belukha';
        src: url('src/fonts/Belukha.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      
      @font-face {
        font-family: 'JIKHAR_2';
        src: url('src/fonts/JIKHAR_2.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      
      @font-face {
        font-family: 'MovieLettersCyrillic';
        src: url('src/fonts/MovieLettersCyrillic.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      
      @font-face {
        font-family: 'Skratch Punk Regular';
        src: url('src/fonts/Skratch Punk Regular.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      
      @font-face {
        font-family: 'Vogue Bold';
        src: url('src/fonts/Vogue Bold.ttf') format('truetype');
        font-weight: bold;
        font-style: normal;
      }
      
      html, body { height: 100%; margin: 0; background:#111; overflow: hidden; }
      #game {
        width: 100vw;
        height: var(--app-vh, 100dvh);
        display:flex;
      }
      canvas { display:block; margin:auto; image-rendering: pixelated; image-rendering: crisp-edges; }
      
      /* Защита от случайных кликов в модальном окне */
      .modal {
        pointer-events: auto;
        touch-action: pan-y; /* Разрешаем только вертикальный скролл */
      }
      
      /* Предотвращаем горизонтальные жесты в модальном окне */
      .room-selection-grid {
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
      }
    </style>
  </head>
  <body>
    <div id="game"></div>

    <!-- Game UI Overlay Container -->
    <div id="game-ui-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: auto; z-index: 10000; pointer-events: none;"></div>

    <script type="module" src="/src/main.ts"></script>
    <script type="module" src="/src/ui/ui-manager.js"></script>
  </body>
  <script>
    // Mobile viewport height fix (fallback for browsers without 100dvh)
    function setAppVh() {
      document.documentElement.style.setProperty('--app-vh', window.innerHeight + 'px')
    }
    setAppVh()
    window.addEventListener('resize', setAppVh)
    window.addEventListener('orientationchange', setAppVh)

    // Prevent passive pinch-zoom scroll issues on mobile
    document.addEventListener('gesturestart', function (e) { e.preventDefault() }, { passive: false })

    // Ensure Phaser interactions are enabled by default when page loads
    window.addEventListener('load', function() {
      console.log('[ModalManager] Page loaded, ensuring Phaser interactions are enabled');
      setTimeout(() => {
        window.enablePhaserInteractions();
      }, 500); // Give time for Phaser to initialize
    });
  </script>

  <!-- Global UI functions for HTML overlay -->
  <script>
    // Global functions for UI overlay button clicks
    window.openInventory = function() {
      console.log('[openInventory] Opening inventory modal');
      
      // Open modal first
      openModal('inventory-modal');

      // Initialize weapon system when inventory is opened
      setTimeout(() => {
        console.log('[openInventory] Initializing weapon system...');
        
        if (window.initializeWeaponSystem) {
          window.initializeWeaponSystem();
        } else {
          console.warn('[openInventory] initializeWeaponSystem function not found');
        }

        // Принудительно синхронизируем оружие
        if (window.forceWeaponSync) {
          setTimeout(() => {
            window.forceWeaponSync();
            console.log('[openInventory] Weapon sync completed');
          }, 50);
        }

        // Обновляем инвентарь на основе текущего состояния GameScene
        if (window.game && window.game.scene && typeof populateInventoryModal === 'function') {
          const gameScene = window.game.scene.getScene('Game');
          if (gameScene && gameScene.inventoryRows) {
            console.log(`[openInventory] Refreshing inventory with ${gameScene.inventoryRows} rows from GameScene`);

            // Обновляем ресурсы
            if (window.updateAllResourceDisplays) {
              window.updateAllResourceDisplays();
            }

            // Используем реальный инвентарь из GameScene если доступен
            let inventoryData = [];
            if (gameScene.getDefaultInventory) {
              inventoryData = gameScene.getDefaultInventory();
            }

            populateInventoryModal(inventoryData, gameScene.inventoryRows);
          }
        }
        
        console.log('[openInventory] Inventory modal setup completed');
      }, 100);
    };

    // Также добавляем функции в глобальное пространство имен без префикса window
    openInventory = window.openInventory;
    openJournal = window.openJournal;
    openAbilities = window.openAbilities;

    // Функция для открытия журнала уведомлений
    window.openJournal = function() {
      console.log('[openJournal] Opening journal modal');
      
      // Заполняем журнал уведомлениями
      if (window.populateJournalModal) {
        window.populateJournalModal();
      }
      
      // Открываем модальное окно
      openModal('journal-modal');
    };

        // Функция для заполнения журнала уведомлений
    window.populateJournalModal = function() {
      const journalContent = document.getElementById('journal-content');
      if (!journalContent) {
        return;
      }

      // Ждем небольшой задержки, чтобы убедиться, что модальное окно полностью загружено
      setTimeout(() => {
        // Инициализируем фильтры по меткам
        window.initializeTagFilters();

        // Продолжаем с остальной логикой
        continuePopulateJournal();
      }, 100);

      function continuePopulateJournal() {

        // Получаем все уведомления
        const notifications = window.gameNotifications.getAll();

        if (notifications.length === 0) {
          journalContent.innerHTML = '<div class="no-notifications">Пока нет уведомлений</div>';
          return;
        }

        // Применяем фильтры
        const filteredNotifications = window.gameNotifications.applyFilters(notifications);

        // Группируем отфильтрованные уведомления по дням
        const notificationsByDay = {};
        filteredNotifications.forEach(notification => {
          if (!notificationsByDay[notification.day]) {
            notificationsByDay[notification.day] = [];
          }
          notificationsByDay[notification.day].push(notification);
        });

        // Сортируем дни по убыванию
        const sortedDays = Object.keys(notificationsByDay).sort((a, b) => parseInt(b) - parseInt(a));

        let journalHTML = '';

        sortedDays.forEach(day => {
          const dayNotifications = notificationsByDay[day];

          journalHTML += `
            <div class="journal-day">
              <h3 class="day-header">День ${day}</h3>
              <div class="day-notifications">
          `;

          dayNotifications.forEach(notification => {
            const typeClass = notification.type || 'info';
            const readClass = notification.read ? 'read' : 'unread';

            // Формируем HTML для меток
            const tagsHTML = notification.tags && notification.tags.length > 0 ?
              `<div class="notification-tags">
                ${notification.tags.map(tag => `<span class="notification-tag ${tag}">${window.getTagLabel(tag)}</span>`).join('')}
              </div>` : '';

            journalHTML += `
              <div class="notification-item ${typeClass} ${readClass}" data-id="${notification.id}">
                <div class="notification-content">
                  <div class="notification-message">${notification.message}</div>
                  <div class="notification-meta">
                    <span class="notification-time">${notification.timestamp}</span>
                    <span class="notification-type">${window.getTypeLabel(notification.type)}</span>
                  </div>
                  ${tagsHTML}
                </div>
                <div class="notification-actions">
                  <button class="mark-read-btn" onclick="window.markNotificationAsRead('${notification.id}')"
                          ${notification.read ? 'disabled' : ''}>
                    ${notification.read ? '✓' : 'Отметить прочитанным'}
                  </button>
                </div>
              </div>
            `;
          });

          journalHTML += `
              </div>
            </div>
          `;
        });

        journalContent.innerHTML = journalHTML;

        // Обновляем статистику
        const totalElement = document.getElementById('total-notifications');
        const unreadElement = document.getElementById('unread-notifications');

        if (totalElement) {
          totalElement.textContent = filteredNotifications.length;
        }
        if (unreadElement) {
          unreadElement.textContent = window.gameNotifications.getUnreadCount();
        }

        // Обновляем счетчик непрочитанных
        window.gameNotifications.updateNotificationCounter();


      }
    };

    // Функция для получения метки типа уведомления
    window.getTypeLabel = function(type) {
      const labels = {
        'info': 'Информация',
        'success': 'Успех',
        'warning': 'Предупреждение',
        'error': 'Ошибка'
      };
      return labels[type] || 'Информация';
    };

    // Функция для получения метки метки
    window.getTagLabel = function(tag) {
      const labels = {
        'resident': 'Жители',
        'enemy': 'Враги',
        'resource': 'Ресурсы',
        'building': 'Строительство',
        'combat': 'Бой',
        'system': 'Система',
        'negative': 'Негативные'
      };
      return labels[tag] || tag;
    };

    // Функция для отметки уведомления как прочитанного
    window.markNotificationAsRead = function(id) {
      window.gameNotifications.markAsRead(id);
      
      // Обновляем UI
      const notificationElement = document.querySelector(`[data-id="${id}"]`);
      if (notificationElement) {
        notificationElement.classList.remove('unread');
        notificationElement.classList.add('read');
        
        // Обновляем кнопку
        const button = notificationElement.querySelector('.mark-read-btn');
        if (button) {
          button.textContent = '✓';
          button.disabled = true;
        }
      }
      
      // Обновляем счетчик
      window.gameNotifications.updateNotificationCounter();
    };

    // Функции для интеграции с Phaser
    window.addGameNotification = function(message, type = 'info', day = null, tags = []) {
      window.gameNotifications.add(message, type, day, tags);
    };

    // Функция для получения текущего дня игры
    window.getCurrentGameDay = function() {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.dayNumber) {
          return gameScene.dayNumber;
        }
      }
      return 1; // fallback
    };

    window.openAbilities = function() {
      // Populate abilities and open modal
      if (typeof populateAbilitiesModal === 'function') {
        populateAbilitiesModal(null); // Will use sample data
      }
      openModal('abilities-modal');

      // Initialize weapon system when abilities modal is opened
      setTimeout(() => {
        if (window.initializeWeaponSystem) {
          window.initializeWeaponSystem();
        }
      }, 100);
    };

    // Weapon system functions
    window.currentWeapon = 'pistol';
    window.weaponDropdownVisible = false;

    // Функция для синхронизации оружия с GameScene
    window.syncWeaponWithGameScene = function(weaponType) {
      console.log(`[syncWeaponWithGameScene] Syncing weapon: ${weaponType}`);
      
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && typeof gameScene.setCurrentWeapon === 'function') {
          // Преобразуем ID оружия из инвентаря в ID для GameScene
          let gameSceneWeaponType;
          switch (weaponType) {
            case 'pistol':
              gameSceneWeaponType = 'pistol';
              break;
            case 'shotgun':
              gameSceneWeaponType = 'shotgun';
              break;
            case 'assault_rifle':
              gameSceneWeaponType = 'ar';
              break;
            case 'sniper_rifle':
              gameSceneWeaponType = 'sniper';
              break;
            default:
              gameSceneWeaponType = 'pistol';
          }
          
          console.log(`[syncWeaponWithGameScene] Setting GameScene weapon to: ${gameSceneWeaponType}`);
          gameScene.setCurrentWeapon(gameSceneWeaponType);
          
          // Проверяем, что оружие действительно установлено
          setTimeout(() => {
            const actualWeapon = gameScene.getCurrentWeapon();
            console.log(`[syncWeaponWithGameScene] GameScene weapon confirmed: ${actualWeapon}`);
          }, 50);
        } else {
          console.warn('[syncWeaponWithGameScene] GameScene or setCurrentWeapon not available');
        }
      } else {
        console.warn('[syncWeaponWithGameScene] window.game not available');
      }
    };

    // Функция для получения текущего оружия из GameScene
    window.getCurrentWeaponFromGameScene = function() {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && typeof gameScene.getCurrentWeapon === 'function') {
          const gameSceneWeapon = gameScene.getCurrentWeapon();
          console.log(`[getCurrentWeaponFromGameScene] GameScene weapon: ${gameSceneWeapon}`);
          return gameSceneWeapon;
        }
      }
      console.warn('[getCurrentWeaponFromGameScene] GameScene not available');
      return 'pistol'; // fallback
    };

    // Функция для принудительной синхронизации оружия между инвентарем и GameScene
    window.forceWeaponSync = function() {
      console.log('[forceWeaponSync] Forcing weapon synchronization');
      
      // Получаем оружие из GameScene
      const gameSceneWeapon = window.getCurrentWeaponFromGameScene();
      
      // Преобразуем в ID для инвентаря
      let inventoryWeaponType;
      switch (gameSceneWeapon) {
        case 'pistol':
          inventoryWeaponType = 'pistol';
          break;
        case 'shotgun':
          inventoryWeaponType = 'shotgun';
          break;
        case 'ar':
          inventoryWeaponType = 'assault_rifle';
          break;
        case 'sniper':
          inventoryWeaponType = 'sniper_rifle';
          break;
        default:
          inventoryWeaponType = 'pistol';
      }
      
      // Обновляем инвентарь
      if (window.currentWeapon !== inventoryWeaponType) {
        console.log(`[forceWeaponSync] Updating inventory weapon from ${window.currentWeapon} to ${inventoryWeaponType}`);
        window.currentWeapon = inventoryWeaponType;
        window.updateWeaponDisplay(inventoryWeaponType);
      }
      
      console.log(`[forceWeaponSync] Weapon sync completed. Inventory: ${window.currentWeapon}, GameScene: ${gameSceneWeapon}`);
    };

    window.toggleWeaponDropdown = function() {
      const dropdown = document.getElementById('weapon-dropdown');
      if (dropdown) {
        window.weaponDropdownVisible = !window.weaponDropdownVisible;
        if (window.weaponDropdownVisible) {
          dropdown.classList.add('show');
          if (window.updateWeaponAvailability) window.updateWeaponAvailability();
        } else {
          dropdown.classList.remove('show');
        }
      }
    };

    window.selectWeapon = function(weaponType) {
      console.log(`[selectWeapon] Selecting weapon: ${weaponType}`);
      
      if (window.isWeaponAvailable && !window.isWeaponAvailable(weaponType)) {
        if (window.showToast) window.showToast('Это оружие требует изучения способности!');
        return;
      }

      // Обновляем текущее оружие в инвентаре
      window.currentWeapon = weaponType;
      console.log(`[selectWeapon] Inventory weapon updated to: ${weaponType}`);
      
      // Обновляем отображение в инвентаре
      if (window.updateWeaponDisplay) {
        window.updateWeaponDisplay(weaponType);
        console.log(`[selectWeapon] Weapon display updated in inventory`);
      }
      
      // Закрываем выпадающий список
      window.weaponDropdownVisible = false;
      const dropdown = document.getElementById('weapon-dropdown');
      if (dropdown) {
        dropdown.classList.remove('show');
      }

      // Синхронизируем с GameScene
      if (window.syncWeaponWithGameScene) {
        window.syncWeaponWithGameScene(weaponType);
        console.log(`[selectWeapon] Weapon synced with GameScene`);
      }

      // Показываем уведомление
      if (window.showToast) {
        const weaponName = window.getWeaponDisplayName ? window.getWeaponDisplayName(weaponType) : weaponType;
        let message = `Выбрано оружие: ${weaponName}`;
        
        // Показываем уникальную механику для штурмовой винтовки
        if (weaponType === 'assault_rifle') {
          message += '\nКлик - одиночный выстрел, удерживание - автоматический огонь (3 выстрела/сек)';
        }
        
        window.showToast(message);
      }
      
      console.log(`[selectWeapon] Weapon selection completed for: ${weaponType}`);
    };

    window.getWeaponData = function(weaponType) {
      const weapons = {
        pistol: {
          name: 'Пистолет',
          icon: 'src/sprites/guns/img/pistol.png',
          damage: 1,
          ammoType: 'pistol'
        },
        shotgun: {
          name: 'Дробовик',
          icon: 'src/sprites/guns/img/shotgun.png',
          damage: 2,
          ammoType: 'shotgun'
        },
        assault_rifle: {
          name: 'Штурмовая винтовка',
          icon: 'src/sprites/guns/img/assault_rifle.png',
          damage: 1,
          ammoType: 'assault_rifle'
        },
        sniper_rifle: {
          name: 'Снайперская винтовка',
          icon: 'src/sprites/guns/img/sniper_rifle.png',
          damage: 3,
          ammoType: 'sniper_rifle'
        }
      };

      return weapons[weaponType] || weapons.pistol;
    };

    window.getWeaponDisplayName = function(weaponType) {
      const weaponData = window.getWeaponData(weaponType);
      return weaponData.name;
    };

    window.isWeaponAvailable = function(weaponType) {
      if (weaponType === 'pistol') return true;

      if (typeof window.getAbilitiesData === 'function') {
        try {
          const abilitiesData = window.getAbilitiesData();
          if (abilitiesData && abilitiesData.abilitiesData) {
            const defenseAbilities = abilitiesData.abilitiesData.defense;
            if (Array.isArray(defenseAbilities)) {
              switch (weaponType) {
                case 'shotgun':
                  const shotgunAbility = defenseAbilities.find(ability => ability.id === 'def_shotgun');
                  return shotgunAbility && shotgunAbility.currentLevel > 0;
                case 'assault_rifle':
                  const assaultRifleAbility = defenseAbilities.find(ability => ability.id === 'def_assault_rifle');
                  return assaultRifleAbility && assaultRifleAbility.currentLevel > 0;
                case 'sniper_rifle':
                  const sniperRifleAbility = defenseAbilities.find(ability => ability.id === 'def_sniper_rifle');
                  return sniperRifleAbility && sniperRifleAbility.currentLevel > 0;
                default:
                  return false;
              }
            }
          }
        } catch (error) {
          console.warn('Error checking weapon availability:', error);
        }
      }

      return false;
    };

    window.updateWeaponDisplay = function(weaponType) {
      const icon = document.getElementById('current-weapon-icon');
      const name = document.getElementById('current-weapon-name');
      const weaponSlot = document.querySelector('.weapon-slot');

      if (icon && name && weaponSlot) {
        const weaponData = window.getWeaponData(weaponType);
        icon.src = weaponData.icon;
        icon.alt = weaponData.name;
        name.textContent = weaponData.name;
        weaponSlot.setAttribute('data-current-weapon', weaponType);
      }
    };

    window.updateWeaponAvailability = function() {
      const weaponOptions = document.querySelectorAll('.weapon-option');

      weaponOptions.forEach(option => {
        const weaponType = option.dataset.weapon;
        const isAvailable = window.isWeaponAvailable(weaponType);

        if (isAvailable) {
          option.classList.remove('locked');
          const status = option.querySelector('.weapon-option-status');
          if (status) {
            status.textContent = '✓';
            status.className = 'weapon-option-status available';
          }
        } else {
          option.classList.add('locked');
          const status = option.querySelector('.weapon-option-status');
          if (status) {
            status.textContent = '🔒';
            status.className = 'weapon-option-status locked';
          }
        }
      });
    };

    window.initializeWeaponSystem = function() {
      console.log('[initializeWeaponSystem] Starting weapon system initialization');
      
      // Синхронизируем с GameScene, если доступен
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && typeof gameScene.getCurrentWeapon === 'function') {
          const gameSceneWeapon = gameScene.getCurrentWeapon();
          console.log(`[initializeWeaponSystem] GameScene weapon: ${gameSceneWeapon}`);
          
          // Преобразуем ID оружия из GameScene в ID для инвентаря
          let inventoryWeaponType;
          switch (gameSceneWeapon) {
            case 'pistol':
              inventoryWeaponType = 'pistol';
              break;
            case 'shotgun':
              inventoryWeaponType = 'shotgun';
              break;
            case 'ar':
              inventoryWeaponType = 'assault_rifle';
              break;
            case 'sniper':
              inventoryWeaponType = 'sniper_rifle';
              break;
            default:
              inventoryWeaponType = 'pistol';
          }
          
          // Обновляем текущее оружие в инвентаре, если оно отличается
          if (inventoryWeaponType !== window.currentWeapon) {
            console.log(`[initializeWeaponSystem] Syncing inventory weapon from ${window.currentWeapon} to ${inventoryWeaponType}`);
            window.currentWeapon = inventoryWeaponType;
          }
        } else {
          console.log('[initializeWeaponSystem] GameScene not available, using default weapon');
        }
      } else {
        console.log('[initializeWeaponSystem] window.game not available, using default weapon');
      }
      
      console.log(`[initializeWeaponSystem] Final inventory weapon: ${window.currentWeapon}`);
      
      // Обновляем отображение и доступность
      window.updateWeaponDisplay(window.currentWeapon);
      window.updateWeaponAvailability();
      
      console.log('[initializeWeaponSystem] Weapon system initialization completed');
    };

    // Система уведомлений и журнала
    window.gameNotifications = {
      notifications: [],
      maxDays: 3,
      
      // Добавить уведомление
      add: function(message, type = 'info', day = null, tags = []) {
        const currentDay = day || (window.game && window.game.scene ? 
          window.game.scene.getScene('Game')?.dayNumber || 1 : 1);
        
        // Автоматически определяем метки на основе сообщения и типа
        const autoTags = this.autoDetectTags(message, type);
        const allTags = [...new Set([...tags, ...autoTags])];
        
        const notification = {
          id: Date.now() + Math.random(),
          message: message,
          type: type, // 'info', 'success', 'warning', 'error'
          day: currentDay,
          timestamp: new Date().toLocaleTimeString(),
          read: false,
          tags: allTags
        };
        
        this.notifications.push(notification);
        
        // Очищаем старые дни
        this.cleanupOldDays();
        
        // Показываем toast уведомление
        this.showToast(message, type);
        
        // Обновляем счетчик непрочитанных уведомлений
        this.updateNotificationCounter();
        

      },
      
      // Автоматическое определение меток на основе сообщения
      autoDetectTags: function(message, type) {
        const tags = [];
        const lowerMessage = message.toLowerCase();

        // Метки по типу события
        if (type === 'error') {
          tags.push('combat', 'negative');
        }
        if (type === 'warning') {
          tags.push('negative');
        }

        // Метки по содержимому сообщения
        if (lowerMessage.includes('житель') || lowerMessage.includes('посетитель') || lowerMessage.includes('принят') || lowerMessage.includes('отказано')) {
          tags.push('resident');
        }
        if (lowerMessage.includes('враг') || lowerMessage.includes('мародер') || lowerMessage.includes('зомби') || lowerMessage.includes('мутант') || lowerMessage.includes('солдат')) {
          tags.push('enemy');
        }
        if (lowerMessage.includes('еда') || lowerMessage.includes('вода') || lowerMessage.includes('патрон') || lowerMessage.includes('деньги') || lowerMessage.includes('ресурс')) {
          tags.push('resource');
        }
        if (lowerMessage.includes('комната') || lowerMessage.includes('построена') || lowerMessage.includes('уничтожена') || lowerMessage.includes('склад')) {
          tags.push('building');
        }
        if (lowerMessage.includes('убил') || lowerMessage.includes('погиб') || lowerMessage.includes('атака') || lowerMessage.includes('бой')) {
          tags.push('combat');
        }
        if (lowerMessage.includes('день') || lowerMessage.includes('ночь') || lowerMessage.includes('уровень') || lowerMessage.includes('инвентарь')) {
          tags.push('system');
        }

        return tags;
      },
      
      // Показать toast уведомление
      showToast: function(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast-notification toast-${type}`;
        toast.textContent = message;
        
        // Определяем цвет в зависимости от типа
        let bgColor, textColor;
        switch (type) {
          case 'success':
            bgColor = 'rgba(76, 175, 80, 0.9)'; // Зеленый
            textColor = 'white';
            break;
          case 'warning':
            bgColor = 'rgba(255, 152, 0, 0.9)'; // Оранжевый
            textColor = 'white';
            break;
          case 'error':
            bgColor = 'rgba(244, 67, 54, 0.9)'; // Красный
            textColor = 'white';
            break;
          default:
            bgColor = 'rgba(0, 0, 0, 0.9)'; // Черный
            textColor = 'white';
        }
        
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${bgColor};
          color: ${textColor};
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 10000;
          font-size: 14px;
          font-weight: 500;
          pointer-events: none;
          opacity: 0;
          transition: all 0.3s ease;
          max-width: 400px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          transform: translateX(100%);
        `;

        document.body.appendChild(toast);

        // Анимация появления
        setTimeout(() => {
          toast.style.opacity = '1';
          toast.style.transform = 'translateX(0)';
        }, 10);

        // Автоматическое скрытие
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateX(100%)';
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, 4000);
      },
      
      // Очистить уведомления старше maxDays
      cleanupOldDays: function() {
        if (!window.game || !window.game.scene) return;
        
        const gameScene = window.game.scene.getScene('Game');
        if (!gameScene || !gameScene.dayNumber) return;
        
        const currentDay = gameScene.dayNumber;
        const cutoffDay = currentDay - this.maxDays;
        
        this.notifications = this.notifications.filter(n => n.day > cutoffDay);

      },
      
      // Получить уведомления для определенного дня
      getByDay: function(day) {
        return this.notifications.filter(n => n.day === day);
      },
      
      // Получить все уведомления
      getAll: function() {
        return this.notifications.slice().reverse(); // Новые сверху
      },
      
      // Отметить уведомление как прочитанное
      markAsRead: function(id) {
        const notification = this.notifications.find(n => n.id === id);
        if (notification) {
          notification.read = true;
        }
      },
      
      // Получить количество непрочитанных уведомлений
      getUnreadCount: function() {
        return this.notifications.filter(n => !n.read).length;
      },
      
      // Обновить счетчик непрочитанных уведомлений
      updateNotificationCounter: function() {
        const counter = document.getElementById('notification-counter');
        if (counter) {
          const count = this.getUnreadCount();
          counter.textContent = count > 0 ? count : '';
          counter.style.display = count > 0 ? 'block' : 'none';
        }
      },
      
      // Применить фильтры к уведомлениям
      applyFilters: function(notifications) {
        const activeTags = window.getActiveTagFilters();
        const activeTypes = window.getActiveTypeFilters();

        const filtered = notifications.filter(notification => {
          // Фильтр по типу - если нет активных фильтров по типу, показываем все
          if (activeTypes.length > 0) {
            if (!activeTypes.includes(notification.type)) {
              return false;
            }
          }

          // Фильтр по меткам - если нет активных фильтров по меткам, показываем все
          if (activeTags.length > 0) {
            const hasMatchingTag = notification.tags && notification.tags.some(tag => activeTags.includes(tag));
            if (!hasMatchingTag) {
              return false;
            }
          }

          return true;
        });

        return filtered;
      },
      
      // Отметить все уведомления дня как прочитанные
      markAllDayAsRead: function(day) {
        const targetDay = day || window.getCurrentGameDay();
        this.notifications.forEach(notification => {
          if (notification.day === targetDay) {
            notification.read = true;
          }
        });
        this.updateNotificationCounter();
        window.populateJournalModal();
      }
    };

    // Алиас для обратной совместимости
    window.showToast = function(message, type = 'info') {
      window.gameNotifications.showToast(message, type);
    };

    // Глобальное состояние активных фильтров по меткам
    if (!window.activeTagFilters) {
      window.activeTagFilters = [];
    }

    // Функции для работы с фильтрами журнала
    window.getActiveTagFilters = function() {
      // Убеждаемся, что массив существует
      if (!window.activeTagFilters) {
        window.activeTagFilters = [];
      }
      return window.activeTagFilters;
    };

        window.getActiveTypeFilters = function() {
      const activeFilters = [];
      const typeFilters = document.querySelectorAll('.type-filters input[type="checkbox"]:checked');
      const allCheckbox = document.querySelector('.type-filters input[value="all"]');

      // Если выбран "Все", возвращаем пустой массив (показываем все типы)
      if (allCheckbox && allCheckbox.checked) {
        return [];
      }

      // Иначе возвращаем только выбранные конкретные типы
      typeFilters.forEach(filter => {
        if (filter.value !== 'all') {
          activeFilters.push(filter.value);
        }
      });

      return activeFilters;
    };

        window.toggleTagFilter = function(tag) {
      // Инициализируем глобальный массив, если он не существует
      if (!window.activeTagFilters) {
        window.activeTagFilters = [];
      }

      const filterElement = document.querySelector(`[data-tag="${tag}"]`);
      if (filterElement) {
        const wasActive = filterElement.classList.contains('active');
        filterElement.classList.toggle('active');
        const isActive = filterElement.classList.contains('active');

        // Обновляем глобальное состояние активных фильтров
        if (isActive) {
          if (!window.activeTagFilters.includes(tag)) {
            window.activeTagFilters.push(tag);
          }
        } else {
          window.activeTagFilters = window.activeTagFilters.filter(t => t !== tag);
        }

        window.populateJournalModal();
      }
    };

    window.markAllDayAsRead = function() {
      const currentDay = window.getCurrentGameDay();
      window.gameNotifications.markAllDayAsRead(currentDay);
    };

        window.clearAllFilters = function() {
      // Сбрасываем глобальное состояние фильтров по меткам
      if (!window.activeTagFilters) {
        window.activeTagFilters = [];
      }
      window.activeTagFilters = [];

      // Сбрасываем фильтры по меткам в DOM
      const activeTagFilters = document.querySelectorAll('.tag-filter.active');
      activeTagFilters.forEach(filter => {
        filter.classList.remove('active');
      });

      // Сбрасываем фильтры по типу
      const typeCheckboxes = document.querySelectorAll('.type-filters input[type="checkbox"]');
      typeCheckboxes.forEach(checkbox => {
        checkbox.checked = true;
      });

      window.populateJournalModal();
    };



    window.initializeTagFilters = function() {
      const tagFiltersContainer = document.getElementById('tag-filters');
      if (!tagFiltersContainer) {
        return;
      }

      // Используем глобальное состояние активных фильтров
      const previouslyActiveTags = window.activeTagFilters;

      // Получаем все уникальные метки из уведомлений
      const allTags = new Set();
      const notifications = window.gameNotifications.getAll();

      notifications.forEach(notification => {
        if (notification.tags) {
          notification.tags.forEach(tag => allTags.add(tag));
        }
      });

      // Создаем фильтры для каждой метки
      tagFiltersContainer.innerHTML = '';
      Array.from(allTags).sort().forEach(tag => {
        const filterElement = document.createElement('div');
        filterElement.className = 'tag-filter';
        filterElement.dataset.tag = tag;
        filterElement.textContent = window.getTagLabel(tag);

        // Восстанавливаем активное состояние фильтра
        if (previouslyActiveTags.includes(tag)) {
          filterElement.classList.add('active');
        }

        filterElement.onclick = (event) => {
          event.stopPropagation();
          window.toggleTagFilter(tag);
        };
        tagFiltersContainer.appendChild(filterElement);
      });

            // Добавляем обработчики для фильтров по типу с задержкой
      setTimeout(() => {
        const typeFilters = document.querySelectorAll('.type-filters input[type="checkbox"]');

        if (typeFilters.length === 0) {
          setTimeout(() => {
            const retryTypeFilters = document.querySelectorAll('.type-filters input[type="checkbox"]');
            setupTypeFilterHandlers(retryTypeFilters);
          }, 100);
          return;
        }

        setupTypeFilterHandlers(typeFilters);
      }, 50);

      // Вспомогательная функция для настройки обработчиков
      function setupTypeFilterHandlers(typeFilters) {
        typeFilters.forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            // Если сняли галочку с "Все", убираем все остальные
            if (checkbox.value === 'all' && !checkbox.checked) {
              typeFilters.forEach(cb => {
                if (cb.value !== 'all') {
                  cb.checked = false;
                }
              });
            }
            // Если поставили галочку на "Все", убираем все остальные
            if (checkbox.value === 'all' && checkbox.checked) {
              typeFilters.forEach(cb => {
                if (cb.value !== 'all') {
                  cb.checked = false;
                }
              });
            }
            // Если поставили галочку на конкретный тип, убираем "Все"
            if (checkbox.value !== 'all' && checkbox.checked) {
              const allCheckbox = document.querySelector('.type-filters input[value="all"]');
              if (allCheckbox) {
                allCheckbox.checked = false;
              }
            }
            // Если сняли все галочки, ставим "Все"
            const checkedTypes = Array.from(typeFilters).filter(cb => cb.checked);
            if (checkedTypes.length === 0) {
              const allCheckbox = document.querySelector('.type-filters input[value="all"]');
              if (allCheckbox) {
                allCheckbox.checked = true;
              }
            }

            window.populateJournalModal();
          });
        });
      }
    };

    // Close weapon dropdown when clicking outside
    document.addEventListener('DOMContentLoaded', function() {
      document.addEventListener('click', function(event) {
        const weaponSlot = document.querySelector('.weapon-slot');
        const dropdown = document.getElementById('weapon-dropdown');

        if (weaponSlot && dropdown && !weaponSlot.contains(event.target)) {
          if (window.weaponDropdownVisible !== undefined) {
            window.weaponDropdownVisible = false;
          }
          if (dropdown.classList.contains('show')) {
            dropdown.classList.remove('show');
          }
        }
      });
    });

    window.openRoomSelection = function() {
      // Предотвращаем всплытие события, чтобы избежать случайного выбора комнаты
      // Небольшая задержка для предотвращения случайного клика на мобильном
      setTimeout(() => {
        // Populate room selection and open modal
        if (typeof populateRoomSelectionModal === 'function') {
          // Получаем GameScene из window.game
          let gameScene = null;
          if (window.game && window.game.scene) {
            console.log('[HTML] Available scenes:', window.game.scene.scenes.map(s => s.scene.key));
            
            // Пробуем разные варианты имен сцены
            gameScene = window.game.scene.getScene('GameScene') || 
                       window.game.scene.getScene('Game');
            
            // Если не нашли по имени, берем первую доступную сцену Game
            if (!gameScene) {
              const gameScenes = window.game.scene.scenes.filter(s => s.scene.key === 'Game');
              if (gameScenes.length > 0) {
                gameScene = gameScenes[0];
              }
            }
            
            console.log('[HTML] Found gameScene:', !!gameScene);
          }
          populateRoomSelectionModal(gameScene);
        }
        openModal('room-selection-modal');
        // Записываем время открытия модального окна для защиты от случайного выбора
        window.lastRoomModalOpenTime = Date.now();
      }, 100); // Задержка 100мс для предотвращения случайного клика
    };

    window.togglePause = function() {
      // Open menu modal instead of just pausing
      openModal('menu-modal');
    };

    window.openResidents = function() {
      console.log('=== OPENING RESIDENTS MODAL ===');
      console.log('window.game exists:', !!window.game);
      console.log('window.game.scene exists:', !!(window.game && window.game.scene));

      // Get real data from game scene
      let residents = [];
      if (window.game && window.game.scene) {
        try {
          const gameScene = window.game.scene.getScene('Game');
          console.log('Game scene found:', !!gameScene);

          if (gameScene) {
            // Try to use the new method first
            if (typeof gameScene.getCurrentResidentsData === 'function') {
              residents = gameScene.getCurrentResidentsData();
              console.log('Got residents using getCurrentResidentsData method');
            } else {
              // Fallback to manual data collection
              const rawResidents = gameScene.bunkerResidents || [];
              console.log('Raw residents from game:', rawResidents);
              console.log('Raw residents count:', rawResidents.length);

              residents = rawResidents.map((resident, index) => ({
                id: resident.id,
                index: index,
                name: resident.name,
                age: resident.age,
                gender: resident.gender,
                profession: resident.profession,
                status: resident.status || 'Отдыхает',
                hunger: resident.hunger || 100,
                thirst: resident.thirst || 100,
                energy: resident.energy || 100,
                health: resident.health || 100,
                skills: resident.skills || [],
                itemsText: resident.itemsText || 'Нет предметов',
                admittedAt: resident.admittedAt,
                patient: resident.patient || false,
                isEnemy: false
              }));

              console.log('Formatted residents count:', residents.length);
            }

            if (residents.length > 0) {
              console.log('First resident sample:', residents[0]);
            } else {
              console.warn('No residents found in bunker');
            }
          } else {
            console.error('Game scene not found!');
          }
        } catch (error) {
          console.error('Error getting residents data:', error);
        }
      } else {
        console.warn('window.game or window.game.scene not available');
        console.log('Available window properties:', Object.keys(window).filter(k => k.includes('game')));
      }

      // Store residents data globally for detail view
      window.currentResidentsData = residents;
      console.log('Stored residents data count:', residents.length);

      // If no residents found, try to get them from bunkerView
      if (residents.length === 0 && window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.simpleBunker) {
          console.log('Trying to get residents from bunkerView...');
          // Some residents might be managed by bunkerView
        }
      }

      // Populate modal with data
      if (typeof window.populatePopulationModal === 'function') {
        console.log('Calling populatePopulationModal with', residents.length, 'residents');
        window.populatePopulationModal(residents);
      } else {
        console.error('populatePopulationModal function not found');
      }

      // Open modal
      if (typeof window.openModal === 'function') {
        console.log('Opening population-modal');
        window.openModal('population-modal');
      } else {
        console.error('openModal function not found');
      }

      console.log('=== RESIDENTS MODAL OPENING COMPLETE ===');
    };

    window.openResource = function(resource) {
      console.log('Opening resource modal:', resource);

      // Get resource data from game or use defaults
      let gameData = {
        happiness: 50,
        defense: 50,
        ammo: 100,
        comfort: 100,
        food: 100,
        water: 100,
        money: 200,
        population: 0
      };

      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene) {
          gameData = {
            happiness: gameScene.happiness || 50,
            defense: gameScene.defense || 50,
            ammo: gameScene.ammo || 100,
            comfort: gameScene.comfort || 100,
            food: gameScene.food || 100,
            water: gameScene.water || 100,
            money: gameScene.money || 200,
            population: gameScene.bunkerResidents ? gameScene.bunkerResidents.length : 0
          };
        }
      }

      // Populate modal with data
      if (typeof window.populateResourceModal === 'function') {
        window.populateResourceModal(resource, gameData);
      }

      // Open modal
      if (typeof window.openModal === 'function') {
        window.openModal('resource-modal');
      }
    };

    window.openEnemies = function() {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.showToast) {
          const enemyCount = gameScene.bunkerEnemies ? gameScene.bunkerEnemies.length : 0;
          gameScene.showToast(`Enemies: ${enemyCount}`);
        }
      }
    };

    // Phaser scene interaction control
    let phaserSceneDisabled = false;

    window.disablePhaserInteractions = function() {
      if (phaserSceneDisabled) return;

      phaserSceneDisabled = true;

      // Get the game scene
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene) {
          // Disable input on the scene
          gameScene.input.enabled = false;

          // Disable input on all interactive objects
          gameScene.input.manager.globalTopOnly = true;

          console.log('[ModalManager] Phaser interactions disabled');
        }
      } else {
        console.warn('[ModalManager] Game scene not available, cannot disable interactions');
      }
    };

    window.enablePhaserInteractions = function() {
      if (!phaserSceneDisabled) return;

      phaserSceneDisabled = false;

      // Get the game scene
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene) {
          // Re-enable input on the scene
          gameScene.input.enabled = true;

          // Restore normal input behavior
          gameScene.input.manager.globalTopOnly = false;

          console.log('[ModalManager] Phaser interactions enabled');
        }
      } else {
        console.warn('[ModalManager] Game scene not available, cannot enable interactions');
      }
    };

    // Modal management functions
        window.closeModal = function(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.style.display = 'none';

        // Remove overlay click handler if it exists
        if (modal._overlayClickHandler) {
          modal.removeEventListener('click', modal._overlayClickHandler);
          delete modal._overlayClickHandler;
        }

        // Special handling for abilities modal
        if (modalId === 'abilities-modal') {
          clearAbilityTree();
        }

        // Re-enable Phaser interactions when modal closes
        setTimeout(() => {
          window.enablePhaserInteractions();
        }, 100); // Small delay to ensure modal is fully closed
      }
    };

    window.openModal = function(modalId) {
      const modal = document.getElementById(modalId);
      if (modal) {
        // Disable Phaser interactions when modal opens
        window.disablePhaserInteractions();

        modal.style.display = 'block';

        // Add click handler to close modal when clicking on overlay
        const handleOverlayClick = function(event) {
          // Only close if clicked directly on the modal overlay, not on modal content
          if (event.target === modal) {
            window.closeModal(modalId);
          }
        };

        // Store the handler for later removal
        modal._overlayClickHandler = handleOverlayClick;
        modal.addEventListener('click', handleOverlayClick);
      }
    };

    // Population modal functions
    window.populatePopulationModal = function(residents) {
      const container = document.getElementById('population-list');
      if (!container) return;

      // Сбрасываем состояние модального окна - показываем список жителей
      window.showPopulationList();

      container.innerHTML = '';

      if (residents && residents.length > 0) {
        residents.forEach((resident, index) => {
          const residentDiv = document.createElement('div');
          residentDiv.className = 'resident-item';
          residentDiv.onclick = () => openResidentDetail(index);
          residentDiv.style.cursor = 'pointer';
          residentDiv.style.transition = 'all 0.2s ease';

          // Add hover effect
          residentDiv.onmouseover = () => {
            residentDiv.style.background = '#3a3a3a';
            residentDiv.style.borderColor = '#D4AF37';
          };
          residentDiv.onmouseout = () => {
            residentDiv.style.background = '#2a2a2a';
            residentDiv.style.borderColor = '#555555';
          };

          residentDiv.innerHTML = `
            <div class="resident-info">
              <div class="resident-name">${resident.name}</div>
              <div class="resident-profession">${resident.profession}</div>
            </div>
          `;

          container.appendChild(residentDiv);
        });
      } else {
        container.innerHTML = '<p style="text-align: center; color: #888;">В бункере пока нет жителей</p>';
      }
    };

    window.openResidentDetail = function(index) {
      console.log('Opening resident detail for index:', index);

      // Сохраняем индекс текущего жителя для использования в revealHiddenSkill
      window.currentResidentIndex = index;

      // Get resident data from stored residents
      let resident = window.currentResidentsData ? window.currentResidentsData[index] : null;

      if (!resident) {
        console.error('Resident not found at index:', index);
        return;
      }

      // Sync with real-time data from Phaser
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene) {
          // Try to get fresh data using the new method
          if (typeof gameScene.getResidentById === 'function') {
            const freshData = gameScene.getResidentById(resident.id);
            if (freshData) {
              console.log('Got fresh data for resident:', freshData.name, 'health:', freshData.health);
              resident = { ...resident, ...freshData };
            }
          } else {
            // Fallback to manual sync
            if (gameScene.simpleBunker && gameScene.simpleBunker.residentAgents) {
              const agent = gameScene.simpleBunker.residentAgents.find(a => a.id === resident.id);
              if (agent && agent.health !== undefined) {
                console.log('Syncing health from bunkerView:', agent.health, 'for resident:', resident.name);
                resident.health = agent.health;
              }
            }

            // Also check if resident has updated data in bunkerResidents
            const updatedResident = gameScene.bunkerResidents.find(r => r.id === resident.id);
            if (updatedResident) {
              resident.hunger = updatedResident.hunger || 100;
              resident.thirst = updatedResident.thirst || 100;
              resident.energy = updatedResident.energy || 100;
              resident.health = updatedResident.health || 100;
              resident.status = updatedResident.status || 'Отдыхает';
            }
          }
        }
      }

      console.log('Showing details for resident:', resident.name, 'health:', resident.health);

      // Populate resident detail content
      if (typeof window.populateResidentDetailModal === 'function') {
        window.populateResidentDetailModal(resident);
      }

      // Switch to resident detail view in the same modal
      window.showResidentDetail();
    };

    // Resident detail modal functions
    window.populateResidentDetailModal = function(resident) {
      const container = document.getElementById('resident-detail-content');
      if (!container) return;

      // Format skills - only first skill is visible, others are hidden
      const skillsList = resident.skills && resident.skills.length > 0
        ? resident.skills.map((skill, index) => {
            if (index === 0) {
              // First skill - fully visible
              return `<div class="skill-item ${skill.positive ? 'positive' : 'negative'}">
                <span class="skill-text">${skill.text}</span>
                <span class="skill-effect">${skill.positive ? '✓' : '✗'}</span>
              </div>`;
            } else {
              // Hidden skills - show as "???" with click to reveal
              return `<div class="skill-item hidden-skill" data-skill-index="${index}" onclick="revealHiddenSkill(this, ${index})">
                <span class="skill-text">???</span>
                <span class="skill-effect">?</span>
              </div>`;
            }
          }).join('')
        : '<div class="no-skills">Нет навыков</div>';

      // Create resident detail HTML
      container.innerHTML = `
        <div class="resident-details">
          <div class="detail-section main-info">
            <h3>Основная информация</h3>
            <div class="detail-grid">
              <div class="detail-item">
                <span class="label">Имя:</span>
                <span class="value">${resident.name}</span>
              </div>
              <div class="detail-item">
                <span class="label">Возраст:</span>
                <span class="value">${resident.age} лет</span>
              </div>
              <div class="detail-item">
                <span class="label">Пол:</span>
                <span class="value">${resident.gender === 'М' ? 'Мужской' : 'Женский'}</span>
              </div>
              <div class="detail-item">
                <span class="label">Профессия:</span>
                <span class="value">${resident.profession}</span>
              </div>
              <div class="detail-item">
                <span class="label">Статус:</span>
                <span class="value">${resident.status}</span>
              </div>
              <div class="detail-item">
                <span class="label">В бункере с:</span>
                <span class="value">День ${resident.admittedAt || 1}</span>
              </div>
            </div>
          </div>

          <div class="detail-section status-info">
            <h3>Состояние</h3>
            <div class="status-meters">
              <div class="status-meter">
                <div class="meter-label">Здоровье</div>
                <div class="meter-bar">
                  <div class="meter-fill health" style="width: ${resident.health}%"></div>
                </div>
                <span class="meter-value">${Math.round(resident.health)}%</span>
              </div>
            </div>
          </div>

          ${resident.skills && resident.skills.length > 0 ? `
            <div class="detail-section skills-info">
              <h3>Навыки</h3>
              <div class="skills-grid">
                ${skillsList}
              </div>
            </div>
          ` : ''}

          <div class="detail-section inventory-info">
            <h3>Инвентарь</h3>
            <p>${resident.itemsText}</p>
          </div>
        </div>
      `;
    };

    // Resource modal functions
    window.populateResourceModal = function(resourceType, data) {
      const title = document.getElementById('resource-modal-title');
      const content = document.getElementById('resource-modal-content');

      if (!title || !content) return;

      title.textContent = resourceType.toUpperCase();

      let details = '';

      switch(resourceType.toLowerCase()) {
        case 'happiness':
          details = `
            <div class="resource-details">
              <div class="resource-stat positive">
                <span>Текущий уровень</span>
                <span>${data.happiness}%</span>
              </div>
              <div class="resource-stat neutral">
                <span>От чего зависит</span>
                <span>Уровень комфорта, наличие работы, здоровье</span>
              </div>
              <div class="resource-stat neutral">
                <span>На что влияет</span>
                <span>Довольство жителей, возможность ухода, бунты</span>
              </div>
              <div class="resource-description">
                <p>Счастье жителей влияет на их производительность и лояльность. Низкий уровень счастья может привести к бунтам и снижению эффективности работы.</p>
              </div>
            </div>
          `;
          break;

        case 'defense':
          details = `
            <div class="resource-details">
              <div class="resource-stat positive">
                <span>Текущий уровень</span>
                <span>${data.defense}%</span>
              </div>
              <div class="resource-stat neutral">
                <span>Скорость восстановления</span>
                <span>5 единиц в день</span>
              </div>
              <div class="resource-stat neutral">
                <span>От чего зависит</span>
                <span>Наличие укреплений, оружия, обученных защитников</span>
              </div>
              <div class="resource-stat neutral">
                <span>На что влияет</span>
                <span>Попадание врагов внутрь бункера</span>
              </div>
              <div class="resource-description">
                <p>Защита бункера включает укрепления стен, вооружение и подготовку жителей к обороне. Высокий уровень защиты снижает риск успешных атак врагов.</p>
              </div>
            </div>
          `;
          break;

        case 'ammo':
          details = `
            <div class="resource-details">
              <div class="resource-stat positive">
                <span>Общее количество патронов</span>
                <span>${data.ammo} шт.</span>
              </div>
              <div class="resource-stat neutral">
                <span>Получение патронов в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-description">
                <p>Патроны используются для защиты бункера от врагов и охоты. Их запас критически важен для выживания в опасном мире.</p>
              </div>
            </div>
          `;
          break;

        case 'food':
          details = `
            <div class="resource-details">
              <div class="resource-stat positive">
                <span>Общее количество</span>
                <span>${data.food} единиц</span>
              </div>
              <div class="resource-stat neutral">
                <span>Общий расход в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-stat neutral">
                <span>Расход на жителя в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-stat neutral">
                <span>Получение от работы в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-description">
                <p>Еда является основным ресурсом для поддержания жизни жителей. Недостаток еды приводит к голоду и снижению здоровья.</p>
              </div>
            </div>
          `;
          break;

        case 'water':
          details = `
            <div class="resource-details">
              <div class="resource-stat positive">
                <span>Общее количество</span>
                <span>${data.water} единиц</span>
              </div>
              <div class="resource-stat neutral">
                <span>Общий расход в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-stat neutral">
                <span>Расход на жителя в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-stat neutral">
                <span>Получение от работы в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-description">
                <p>Вода критически важна для выживания. Её недостаток быстро приводит к обезвоживанию и смерти жителей.</p>
              </div>
            </div>
          `;
          break;

        case 'money':
          details = `
            <div class="resource-details">
              <div class="resource-stat positive">
                <span>Общее количество</span>
                <span>${data.money} монет</span>
              </div>
              <div class="resource-stat neutral">
                <span>Общий расход в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-stat neutral">
                <span>Расход на жителя в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-stat neutral">
                <span>Получение от работы в день</span>
                <span>Заглушка</span>
              </div>
              <div class="resource-description">
                <p>Деньги используются для покупки ресурсов, найма специалистов и улучшения бункера. Они также нужны для поддержания нормальной жизни.</p>
              </div>
            </div>
          `;
          break;

        case 'comfort':
          details = `
            <div class="resource-details">
              <div class="resource-stat positive">
                <span>Текущий уровень</span>
                <span>${data.comfort}%</span>
              </div>
              <div class="resource-stat neutral">
                <span>От чего зависит</span>
                <span>Качество помещений, наличие удобств, освещение</span>
              </div>
              <div class="resource-stat neutral">
                <span>На что влияет</span>
                <span>Привлечение новых жителей</span>
              </div>
              <div class="resource-description">
                <p>Комфорт влияет на мораль и здоровье жителей. Хорошие условия жизни повышают производительность и снижают риск заболеваний.</p>
              </div>
            </div>
          `;
          break;

        default:
          details = '<p>Информация о ресурсе недоступна</p>';
      }

      content.innerHTML = details;
    };

    // Menu functions
    window.continueGame = function() {
      closeModal('menu-modal');
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.showToast) {
          gameScene.showToast('Продолжаем игру...');
        }
      }
    };

    window.saveGame = function() {
      closeModal('menu-modal');
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.showToast) {
          gameScene.showToast('Игра сохранена!');
        }
      }
    };

    window.loadGame = function() {
      closeModal('menu-modal');
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.showToast) {
          gameScene.showToast('Загрузка игры... (WIP)');
        }
      }
    };

    window.openSettings = function() {
      closeModal('menu-modal');
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.showToast) {
          gameScene.showToast('Настройки (WIP)');
        }
      }
    };

    window.exitToMenu = function() {
      if (confirm('Вы уверены, что хотите выйти в главное меню?')) {
        closeModal('menu-modal');
        if (window.game && window.game.scene) {
          const gameScene = window.game.scene.getScene('Game');
          if (gameScene && gameScene.showToast) {
            gameScene.showToast('Возвращение в главное меню...');
          }
        }
      }
    };

    // Inventory functions
    // Функция для получения предмета по ID
    window.getItemById = function(id) {
      // Загружаем справочник предметов из GameScene если доступен
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.getItemById) {
          return gameScene.getItemById(id);
        }
      }

      // Fallback: создаем базовые предметы если справочник недоступен
      const fallbackItems = {
        'food': { id: 'food', name: 'Еда', spritePath: 'src/sprites/items/food.png', description: 'Восстанавливает здоровье', price: 10 },
        'water': { id: 'water', name: 'Вода', spritePath: 'src/sprites/items/water.png', description: 'Необходима для выживания', price: 8 },
        'medicine': { id: 'medicine', name: 'Лекарство', spritePath: 'src/sprites/items/medicine.png', description: 'Восстанавливает здоровье', price: 40 },
        'ammo': { id: 'ammo', name: 'Патроны', spritePath: 'src/sprites/items/ammo.png', description: 'Боеприпасы для оружия', price: 15 },
        'multi_tool': { id: 'multi_tool', name: 'Мультитул', spritePath: 'src/sprites/items/multi_tool.png', description: 'Набор инструментов', price: 75 },
        'flashlight': { id: 'flashlight', name: 'Фонарик', spritePath: 'src/sprites/items/flashlight.png', description: 'Источник света', price: 35 },
        'bottle': { id: 'bottle', name: 'Бутылка', spritePath: 'src/sprites/items/bottle.png', description: 'Пустая бутылка', price: 5 },
        'compass': { id: 'compass', name: 'Компас', spritePath: 'src/sprites/items/compass.png', description: 'Помогает ориентироваться', price: 45 },
        'map': { id: 'map', name: 'Карта', spritePath: 'src/sprites/items/map.png', description: 'Помогает ориентироваться', price: 30 },
        'backpack': { id: 'backpack', name: 'Рюкзак', spritePath: 'src/sprites/items/backpack.png', description: 'Увеличивает вместимость', price: 50 },
        'battery': { id: 'battery', name: 'Батарейка', spritePath: 'src/sprites/items/battery.png', description: 'Источник энергии', price: 12 },
        'lighter': { id: 'lighter', name: 'Зажигалка', spritePath: 'src/sprites/items/lighter.png', description: 'Для разжигания огня', price: 15 },
        'matches': { id: 'matches', name: 'Спички', spritePath: 'src/sprites/items/matches.png', description: 'Для разжигания огня', price: 10 },
        'coal': { id: 'coal', name: 'Уголь', spritePath: 'src/sprites/items/coal.png', description: 'Топливо', price: 8 },
        'wood': { id: 'wood', name: 'Дерево', spritePath: 'src/sprites/items/wood.png', description: 'Материал для строительства', price: 12 },
        'metal': { id: 'metal', name: 'Металл', spritePath: 'src/sprites/items/metal.png', description: 'Материал для крафта', price: 20 },
        'glass': { id: 'glass', name: 'Стекло', spritePath: 'src/sprites/items/glass.png', description: 'Материал для крафта', price: 12 },
        'nails': { id: 'nails', name: 'Гвозди', spritePath: 'src/sprites/items/nails.png', description: 'Материал для строительства', price: 10 },
        'tape': { id: 'tape', name: 'Скотч', spritePath: 'src/sprites/items/tape.png', description: 'Для склеивания', price: 8 },
        'paper': { id: 'paper', name: 'Бумага', spritePath: 'src/sprites/items/paper.png', description: 'Материал для записей', price: 5 }
      };

      return fallbackItems[id] || null;
    };

    window.populateInventoryModal = function(inventory, inventoryRows = 1) {
      console.log(`[populateInventoryModal] Called with inventoryRows: ${inventoryRows}, inventory length: ${inventory ? inventory.length : 0}`);

      const grid = document.getElementById('inventory-grid');
      if (!grid) {
        console.log(`[populateInventoryModal] inventory-grid element not found`);
        return;
      }

      // Clear existing slots
      grid.innerHTML = '';

      // Create inventory slots (6 columns × inventoryRows)
      const totalSlots = 6 * inventoryRows;
      console.log(`[populateInventoryModal] Creating ${totalSlots} slots (6 columns × ${inventoryRows} rows)`);

      for (let i = 0; i < totalSlots; i++) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.onclick = () => selectInventorySlot(i);

        const item = inventory ? inventory[i] : null;
        // Проверяем, что предмет существует и не является пустым
        if (item && item.id && item.id.trim() !== '' && item.quantity > 0) {
          slot.classList.add('occupied');

          // Проверяем формат данных: новый (с id) или старый (с icon)
          let itemDisplay = '';
          let itemQuantity = item.quantity || 1;

          if (item.id) {
            // Новый формат: ищем предмет в справочнике
            const itemData = window.getItemById(item.id);
            if (itemData) {
              itemDisplay = `<img src="${itemData.spritePath}" alt="${itemData.name}" style="width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated;">`;
            } else {
              itemDisplay = `❓`; // Неизвестный предмет
            }
          } else if (item.icon) {
            // Старый формат: используем иконку
            itemDisplay = item.icon;
          } else {
            // Fallback
            itemDisplay = '📦';
          }

          slot.innerHTML = `
            <div class="item">${itemDisplay}</div>
            <div class="quantity">${itemQuantity}</div>
          `;
        } else {
          // Пустой слот - очищаем содержимое
          slot.classList.remove('occupied');
          slot.innerHTML = '';
        }

        grid.appendChild(slot);
      }

      console.log(`[populateInventoryModal] Successfully created ${totalSlots} inventory slots`);

      // Initialize drag and drop after creating slots
      setTimeout(() => {
        if (window.initializeInventoryDragAndDrop) {
          window.initializeInventoryDragAndDrop();
        }
      }, 100);
    };

    window.selectInventorySlot = function(index) {
      console.log('Selected inventory slot:', index);
      // This will be implemented for item interactions
    };

    // Drag and Drop functionality for inventory
    let draggedItem = null;
    let draggedItemIndex = -1;
    let dragGhost = null;
    let dropTarget = null;

    // Initialize drag and drop for inventory slots
    window.initializeInventoryDragAndDrop = function() {
      const slots = document.querySelectorAll('.inventory-slot');
      slots.forEach((slot, index) => {
        // Make slots draggable
        slot.draggable = true;

        // Drag start event
        slot.addEventListener('dragstart', function(e) {
          e.dataTransfer.effectAllowed = 'move';
          draggedItemIndex = index;
          draggedItem = slot.cloneNode(true);

          // Create drag ghost
          dragGhost = slot.cloneNode(true);
          dragGhost.style.position = 'absolute';
          dragGhost.style.opacity = '0.5';
          dragGhost.style.pointerEvents = 'none';
          dragGhost.style.zIndex = '1000';
          dragGhost.style.transform = 'rotate(5deg)';
          document.body.appendChild(dragGhost);

          // Update ghost position
          function updateGhost(e) {
            if (dragGhost) {
              dragGhost.style.left = (e.clientX - 20) + 'px';
              dragGhost.style.top = (e.clientY - 20) + 'px';
            }
          }

          document.addEventListener('drag', updateGhost);

          // Clean up ghost after drag ends
          slot.addEventListener('dragend', function() {
            if (dragGhost) {
              document.body.removeChild(dragGhost);
              dragGhost = null;
            }
            document.removeEventListener('drag', updateGhost);
          }, { once: true });

          console.log(`[Inventory] Started dragging item from slot ${index}`);
        });

        // Drag over event
        slot.addEventListener('dragover', function(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          // Highlight drop target
          if (dropTarget) {
            dropTarget.classList.remove('drag-over');
          }
          slot.classList.add('drag-over');
          dropTarget = slot;
        });

        // Drag leave event
        slot.addEventListener('dragleave', function(e) {
          slot.classList.remove('drag-over');
        });

        // Drop event
        slot.addEventListener('drop', function(e) {
          e.preventDefault();
          slot.classList.remove('drag-over');

          const targetIndex = index;

          if (draggedItemIndex !== -1 && draggedItemIndex !== targetIndex) {
            console.log(`[Inventory] Dropped item from slot ${draggedItemIndex} to slot ${targetIndex}`);
            swapInventoryItems(draggedItemIndex, targetIndex);
          }

          draggedItem = null;
          draggedItemIndex = -1;
        });
      });

      console.log('[Inventory] Drag and drop initialized for all slots');
    };

    // Swap items between inventory slots
    window.swapInventoryItems = function(fromSlot, toSlot) {
      if (fromSlot === toSlot || fromSlot < 0 || toSlot < 0) return false;

      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.swapInventoryItems) {
          const success = gameScene.swapInventoryItems(fromSlot, toSlot);
          if (success) {
            // Refresh inventory display
            refreshInventoryDisplay();
            console.log(`[Inventory] Successfully swapped items between slots ${fromSlot} and ${toSlot}`);
            return true;
          }
        }
      }

      console.warn(`[Inventory] Failed to swap items between slots ${fromSlot} and ${toSlot}`);
      return false;
    };

    // Move item from one slot to another
    window.moveInventoryItem = function(fromSlot, toSlot) {
      if (fromSlot === toSlot || fromSlot < 0 || toSlot < 0) return false;

      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.moveInventoryItem) {
          const success = gameScene.moveInventoryItem(fromSlot, toSlot);
          if (success) {
            // Refresh inventory display
            refreshInventoryDisplay();
            console.log(`[Inventory] Successfully moved item from slot ${fromSlot} to slot ${toSlot}`);
            return true;
          }
        }
      }

      console.warn(`[Inventory] Failed to move item from slot ${fromSlot} to slot ${toSlot}`);
      return false;
    };

    // Refresh inventory display after changes
    function refreshInventoryDisplay() {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.getDefaultInventory && typeof window.populateInventoryModal === 'function') {
          const inventory = gameScene.getDefaultInventory();
          const inventoryRows = gameScene.inventoryRows || 1;
          window.populateInventoryModal(inventory, inventoryRows);
        }
      }
    }

    // Get item from inventory slot
    window.getInventoryItem = function(slot) {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.getInventoryItem) {
          return gameScene.getInventoryItem(slot);
        }
      }
      return null;
    };

    // Set item in inventory slot
    window.setInventoryItem = function(slot, item) {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.setInventoryItem) {
          gameScene.setInventoryItem(slot, item);
          refreshInventoryDisplay();
        }
      }
    };

    // Remove item from inventory slot
    window.removeInventoryItem = function(slot) {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.removeInventoryItem) {
          const removedItem = gameScene.removeInventoryItem(slot);
          refreshInventoryDisplay();
          return removedItem;
        }
      }
      return null;
    };

    // Resource management functions
    window.updateResourceDisplay = function(resource, amount) {
      // Обновляем в UI строке
      const uiElement = document.getElementById(resource);
      if (uiElement) {
        const iconElement = uiElement.querySelector('.resource-icon');
        if (iconElement) {
          uiElement.innerHTML = `${iconElement.outerHTML} ${amount}`;
        } else {
          uiElement.textContent = `${amount}`;
        }
      }

      // Обновляем в инвентаре
      const inventoryElement = document.getElementById(`resource-${resource}-quantity`);
      if (inventoryElement) {
        inventoryElement.textContent = amount.toString();
      }
    };

    window.updateAllResourceDisplays = function() {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene) {
          updateResourceDisplay('food', gameScene.food);
          updateResourceDisplay('water', gameScene.water);
          updateResourceDisplay('money', gameScene.money);
          updateResourceDisplay('ammo', gameScene.ammo);
          updateResourceDisplay('wood', gameScene.wood);
          updateResourceDisplay('metal', gameScene.metal);
          updateResourceDisplay('coal', gameScene.coal);
          updateResourceDisplay('nails', gameScene.nails);
          updateResourceDisplay('paper', gameScene.paper);
          updateResourceDisplay('glass', gameScene.glass);
        }
      }
    };

    window.addResource = function(resource, amount) {
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene) {
          switch (resource) {
            case 'food':
              gameScene.addFood(amount);
              break;
            case 'water':
              gameScene.addWater(amount);
              break;
            case 'money':
              gameScene.money = Math.max(0, gameScene.money + amount);
              break;
            case 'ammo':
              gameScene.ammo = Math.max(0, gameScene.ammo + amount);
              break;
            case 'wood':
              gameScene.wood = Math.max(0, gameScene.wood + amount);
              break;
            case 'metal':
              gameScene.metal = Math.max(0, gameScene.metal + amount);
              break;
            case 'coal':
              gameScene.coal = Math.max(0, gameScene.coal + amount);
              break;
            case 'nails':
              gameScene.nails = Math.max(0, gameScene.nails + amount);
              break;
            case 'paper':
              gameScene.paper = Math.max(0, gameScene.paper + amount);
              break;
            case 'glass':
              gameScene.glass = Math.max(0, gameScene.glass + amount);
              break;
          }
          updateAllResourceDisplays();
          updateResourceUI(resource, gameScene[resource]);
        }
      }
    };

    window.updateResourceUI = function(resource, amount) {
      const element = document.getElementById(resource);
      if (element) {
        // Обновляем текст, сохраняя иконку
        const iconElement = element.querySelector('.resource-icon');
        if (iconElement) {
          element.innerHTML = `${iconElement.outerHTML} ${amount}`;
        } else {
          element.textContent = `${amount}`;
        }
      }

      // Также обновляем ресурс в инвентаре
      const resourceSlot = document.getElementById(`resource-${resource}`);
      if (resourceSlot) {
        const quantityElement = resourceSlot.querySelector('.resource-quantity');
        if (quantityElement) {
          quantityElement.textContent = amount.toString();
        }
      }
    };

    // Abilities system
    let currentAbilityPoints = 100;
    let currentCategory = 'resources';
    let abilitiesData = {};
    let learnedAbilities = new Set();

    // Initialize abilities data
    function initializeAbilitiesData() {
      abilitiesData = {
        resources: [
          // Базовые способности (1 уровень)
          {
            id: 'res_cooking',
            name: 'Готовка',
            description: 'Повара производят на 1 ед. больше еды',
            cost: 1,
            maxLevel: 2,
            currentLevel: 0,
            position: { x: 50, y: 50 },
            requirements: [],
            icon: '🍳'
          },
          {
            id: 'res_plumbing',
            name: 'Сантехника',
            description: 'Сантехники производят на 1 ед. больше воды',
            cost: 1,
            maxLevel: 2,
            currentLevel: 0,
            position: { x: 200, y: 50 },
            requirements: [],
            icon: '🔧'
          },
          {
            id: 'res_restaurant',
            name: 'Ресторан',
            description: 'В столовой может работать на 1 чел. больше',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 350, y: 50 },
            requirements: [],
            icon: '🍽️'
          },
          {
            id: 'res_brigade',
            name: 'Бригада',
            description: 'В туалете может работать на 1 чел. больше',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 500, y: 50 },
            requirements: [],
            icon: '🚽'
          },
          {
            id: 'res_consultation',
            name: 'Консилиум',
            description: 'В госпитале может работать на 1 чел. больше',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 650, y: 50 },
            requirements: [],
            icon: '🏥'
          },
          
          // Средние способности (2 уровень)
          {
            id: 'res_hunting',
            name: 'Добыча',
            description: 'Охотники приносят на 5% больше еды',
            cost: 2,
            maxLevel: 10,
            currentLevel: 0,
            position: { x: 125, y: 150 },
            requirements: ['res_cooking'],
            icon: '🏹'
          },
          {
            id: 'res_scouting',
            name: 'Разведка',
            description: 'Разведчики приносят больше добычи на 5%',
            cost: 2,
            maxLevel: 10,
            currentLevel: 0,
            position: { x: 275, y: 150 },
            requirements: ['res_plumbing'],
            icon: '🔍'
          },
          {
            id: 'res_science',
            name: 'Наука',
            description: 'Ученые приносят на 1 ед. опыта больше',
            cost: 3,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 425, y: 150 },
            requirements: ['res_restaurant'],
            icon: '🔬'
          },
          {
            id: 'res_chemistry',
            name: 'Химия',
            description: 'Химики приносят на 1 ед. опыта больше',
            cost: 3,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 575, y: 150 },
            requirements: ['res_brigade'],
            icon: '🧪'
          },
          
          // Продвинутые способности (3 уровень)
          {
            id: 'res_market_economy',
            name: 'Рыночная экономика',
            description: 'Продавцы приносят на 1 ед. денег больше',
            cost: 3,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 200, y: 250 },
            requirements: ['res_hunting', 'res_scouting'],
            icon: '💰'
          },
          {
            id: 'res_penicillin',
            name: 'Пенициллин',
            description: 'Доктора восстанавливают на 1 ед. здоровья больше',
            cost: 3,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 500, y: 250 },
            requirements: ['res_science', 'res_chemistry'],
            icon: '💊'
          }
        ],
        bunker: [
          // Базовые способности (1 уровень)
          {
            id: 'bunk_demolition',
            name: 'Демонтаж',
            description: 'Дает доступ к разрушению комнат',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 50, y: 50 },
            requirements: [],
            icon: '💥'
          },
          {
            id: 'bunk_storage',
            name: 'Хранилище',
            description: 'Дает доступ к постройке "Склад"',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 200, y: 50 },
            requirements: [],
            icon: '📦'
          },
          {
            id: 'bunk_elevator',
            name: 'Лифт',
            description: 'Дает доступ к постройке "Лифт"',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 350, y: 50 },
            requirements: [],
            icon: '🛗'
          },
          {
            id: 'bunk_armory',
            name: 'Оружейная',
            description: 'Дает доступ к постройке "Оружейная"',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 500, y: 50 },
            requirements: [],
            icon: '🔫'
          },
          {
            id: 'bunk_server',
            name: 'Серверная',
            description: 'Дает доступ к постройке "Серверная"',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 650, y: 50 },
            requirements: [],
            icon: '💻'
          },
          {
            id: 'bunk_market',
            name: 'Рынок',
            description: 'Дает доступ к постройке "Рынок"',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 800, y: 50 },
            requirements: [],
            icon: '🏪'
          },
          {
            id: 'bunk_classroom',
            name: 'Обучение',
            description: 'Открывает доступ к постройке "Классная комната"',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 950, y: 50 },
            requirements: [],
            icon: '📚'
          },
          
          // Средние способности (2 уровень)
          {
            id: 'bunk_fast_building',
            name: 'Быстрое строительство',
            description: 'Ускоряет постройку на 5%',
            cost: 2,
            maxLevel: 10,
            currentLevel: 0,
            position: { x: 125, y: 150 },
            requirements: ['bunk_demolition'],
            icon: '🏗️'
          },
          {
            id: 'bunk_energy_storage',
            name: 'Энергохранилище',
            description: 'Увеличивает число комнат, питаемых станцией на 1',
            cost: 2,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 275, y: 150 },
            requirements: ['bunk_storage'],
            icon: '⚡'
          },
          {
            id: 'bunk_building_discount',
            name: 'Скидка на строительство',
            description: 'Снижает стоимость постройки на 5%',
            cost: 2,
            maxLevel: 10,
            currentLevel: 0,
            position: { x: 425, y: 150 },
            requirements: ['bunk_elevator'],
            icon: '💰'
          },
          
          // Продвинутые способности (3 уровень)
          {
            id: 'bunk_territory_expansion',
            name: 'Расширение территории',
            description: 'Убирает ограничение по высоте и ширине',
            cost: 3,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 275, y: 250 },
            requirements: ['bunk_fast_building', 'bunk_energy_storage'],
            icon: '🌍'
          }
        ],
        defense: [
          // Базовые способности (1 уровень)
          {
            id: 'def_banishment',
            name: 'Изгнание',
            description: 'Открывает возможность изгнания жителей',
            cost: 1,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 50, y: 50 },
            requirements: [],
            icon: '🚪'
          },
          {
            id: 'def_armor',
            name: 'Броня',
            description: 'Макс. здоровье стен +5 ед.',
            cost: 1,
            maxLevel: 10,
            currentLevel: 0,
            position: { x: 200, y: 50 },
            requirements: [],
            icon: '🛡️'
          },
          {
            id: 'def_repair',
            name: 'Починка',
            description: 'Восстановление здоровья стен +1ед./час',
            cost: 1,
            maxLevel: 5,
            currentLevel: 0,
            position: { x: 350, y: 50 },
            requirements: [],
            icon: '🔧'
          },
          
          // Средние способности (2 уровень)
          {
            id: 'def_damage_boost',
            name: 'Увеличение урона',
            description: 'Увеличение урона от оружия на 1 ед.',
            cost: 2,
            maxLevel: 10,
            currentLevel: 0,
            position: { x: 125, y: 150 },
            requirements: ['def_armor'],
            icon: '⚔️'
          },
          {
            id: 'def_shotgun',
            name: 'Дробовик',
            description: 'Открывает дробовик',
            cost: 2,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 275, y: 150 },
            requirements: ['def_repair'],
            icon: '🔫'
          },
          
          // Продвинутые способности (3 уровень)
          {
            id: 'def_assault_rifle',
            name: 'Штурм',
            description: 'Открывает штурмовую винтовку',
            cost: 3,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 200, y: 250 },
            requirements: ['def_damage_boost', 'def_shotgun'],
            icon: '🔫'
          },
          
          // Элитные способности (4 уровень)
          {
            id: 'def_sniper_rifle',
            name: 'Снайпер',
            description: 'Открывает снайперскую винтовку',
            cost: 4,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 125, y: 350 },
            requirements: ['def_assault_rifle'],
            icon: '🎯'
          },
          {
            id: 'def_execution',
            name: 'Казнь',
            description: 'Открывает возможность убийства посетителей',
            cost: 4,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 275, y: 350 },
            requirements: ['def_assault_rifle'],
            icon: '⚰️'
          },
          {
            id: 'def_army',
            name: 'Армия',
            description: '5% не использовать патроны для Солдат',
            cost: 4,
            maxLevel: 10,
            currentLevel: 0,
            position: { x: 425, y: 350 },
            requirements: ['def_assault_rifle'],
            icon: '👥'
          },
          
          // Легендарные способности (5 уровень)
          {
            id: 'def_masochist',
            name: 'Мазохист',
            description: 'Открывает возможность впустить врага в бункер',
            cost: 5,
            maxLevel: 1,
            currentLevel: 0,
            position: { x: 200, y: 450 },
            requirements: ['def_sniper_rifle', 'def_execution'],
            icon: '😈'
          },
          {
            id: 'def_misfire',
            name: 'Осечка',
            description: 'Шанс не использовать патрон при стрельбе +5%',
            cost: 5,
            maxLevel: 5,
            currentLevel: 0,
            position: { x: 350, y: 450 },
            requirements: ['def_army'],
            icon: '💥'
          }
        ],
        misc: [
          // Базовые способности (1 уровень)
          {
            id: 'misc_skill_points',
            name: 'Увеличение очков',
            description: 'Увеличение количества очков на уровень на 1 ед.',
            cost: 1,
            maxLevel: 3,
            currentLevel: 0,
            position: { x: 50, y: 50 },
            requirements: [],
            icon: '⭐'
          },
          
          // Средние способности (2 уровень)
          {
            id: 'misc_night_speed',
            name: 'Ускорение ночи',
            description: 'Ускорение ночи на 5%',
            cost: 2,
            maxLevel: 5,
            currentLevel: 0,
            position: { x: 125, y: 150 },
            requirements: ['misc_skill_points'],
            icon: '🌙'
          },
          {
            id: 'misc_day_speed',
            name: 'Ускорение дня',
            description: 'Ускорение дня на 5%',
            cost: 2,
            maxLevel: 5,
            currentLevel: 0,
            position: { x: 275, y: 150 },
            requirements: ['misc_skill_points'],
            icon: '☀️'
          }
        ]
      };
    }

    // Abilities functions
    window.populateAbilitiesModal = function(abilities) {
      // Initialize abilities data only once
      if (Object.keys(abilitiesData).length === 0) {
        initializeAbilitiesData();
      }
      
      setupCategoryTabs();
      renderAbilityTree();
      updateAbilityPoints();
    };

    window.populateRoomSelectionModal = function(gameScene = null) {
      console.log('[HTML] populateRoomSelectionModal called with gameScene:', !!gameScene);
      
      const roomSelectionGrid = document.querySelector('.room-selection-grid');
      if (!roomSelectionGrid) return;
      
      // Сохраняем ссылку на GameScene для использования в обработчиках
      window.currentGameScene = gameScene;
      console.log('[HTML] currentGameScene set to:', !!window.currentGameScene);
      
      // Получаем данные о способностях
      const abilitiesData = window.getAbilitiesData ? window.getAbilitiesData() : null;
      console.log('[HTML] Abilities data:', abilitiesData);

      // Clear existing content
      roomSelectionGrid.innerHTML = '';

      // Define available room types with their properties and ability requirements
      const availableRooms = [
        {
          id: 'Спальня',
          name: 'Спальня',
          description: 'Комната для сна жителей. Восстанавливает энергию и здоровье.',
          icon: '🛏️',
          cost: '100 монет',
          requiredAbility: null, // Базовая комната, доступна с самого начала
          category: 'basic'
        },
        {
          id: 'Столовая',
          name: 'Столовая',
          description: 'Место для приема пищи. Увеличивает счастье жителей.',
          icon: '🍽️',
          cost: '150 монет',
          requiredAbility: null, // Базовая комната, доступна с самого начала
          category: 'basic'
        },
        {
          id: 'Туалет',
          name: 'Туалет',
          description: 'Санитарное помещение. Необходимо для комфорта жителей.',
          icon: '🚽',
          cost: '80 монет',
          requiredAbility: null, // Базовая комната, доступна с самого начала
          category: 'basic'
        },
        {
          id: 'Госпиталь',
          name: 'Госпиталь',
          description: 'Медицинское учреждение. Лечит больных жителей.',
          icon: '🏥',
          cost: '200 монет',
          requiredAbility: null, // Базовая комната, доступна с самого начала
          category: 'basic'
        },
        {
          id: 'Склад',
          name: 'Склад',
          description: 'Хранилище для ресурсов и предметов.',
          icon: '📦',
          cost: '90 монет',
          requiredAbility: 'bunk_storage', // Требует способность "Хранилище"
          category: 'advanced'
        },
        {
          id: 'Лифт',
          name: 'Лифт',
          description: 'Вертикальное перемещение между этажами.',
          icon: '🛗',
          cost: '180 монет',
          requiredAbility: 'bunk_elevator', // Требует способность "Лифт"
          category: 'advanced'
        },
        {
          id: 'Оружейная',
          name: 'Оружейная',
          description: 'Хранилище оружия и боеприпасов.',
          icon: '🔫',
          cost: '250 монет',
          requiredAbility: 'bunk_armory', // Требует способность "Оружейная"
          category: 'advanced'
        },
                  {
            id: 'Серверная',
            name: 'Серверная',
            description: 'Техническое помещение для электроники.',
            icon: '💻',
            cost: '300 монет',
            requiredAbility: 'bunk_server', // Требует способность "Серверная"
            category: 'advanced'
          },
        {
          id: 'Рынок',
          name: 'Рынок',
          description: 'Торговое помещение для обмена ресурсами.',
          icon: '🏪',
          cost: '220 монет',
          requiredAbility: 'bunk_market', // Требует способность "Рынок"
          category: 'advanced'
        },
                  {
            id: 'Классная комната',
            name: 'Классная комната',
            description: 'Место для обучения и повышения навыков.',
            icon: '📚',
            cost: '160 монет',
            requiredAbility: 'bunk_classroom', // Требует способность "Классная комната"
            category: 'advanced'
          },
        {
          id: 'Станция',
          name: 'Станция',
          description: 'Электростанция для питания комнат. Обеспечивает энергией до 3 комнат.',
          icon: '⚡',
          cost: '400 монет',
          requiredAbility: null, // Доступна с самого начала (критически важна)
          category: 'critical'
        },
        {
          id: 'Техническая',
          name: 'Техническая',
          description: 'Техническое помещение для обслуживания оборудования и систем.',
          icon: '🔧',
          cost: '180 монет',
          requiredAbility: null, // Доступна с самого начала
          category: 'basic'
        }
      ];

      // Filter rooms based on learned abilities
      console.log('=== ROOM FILTERING DEBUG ===');
      console.log('Total rooms available:', availableRooms.length);
      console.log('Abilities data:', JSON.stringify(abilitiesData, null, 2));

      const filteredRooms = availableRooms.filter(room => {
        console.log(`--- Checking room: ${room.name} ---`);
        console.log(`Required ability: ${room.requiredAbility}`);

        // Если комната не требует способности, она всегда доступна
        if (!room.requiredAbility) {
          console.log(`✅ Room ${room.name} is basic, showing`);
          return true;
        }

        // Проверяем, изучена ли требуемая способность
        if (abilitiesData && abilitiesData.learnedAbilities) {
          console.log(`Learned abilities:`, abilitiesData.learnedAbilities);

          // Проверяем, есть ли способность в массиве изученных (массив может содержать строки или объекты)
          let isLearned = false;

          if (Array.isArray(abilitiesData.learnedAbilities)) {
            // Если массив содержит строки
            if (typeof abilitiesData.learnedAbilities[0] === 'string') {
              isLearned = abilitiesData.learnedAbilities.includes(room.requiredAbility);
            }
            // Если массив содержит объекты
            else if (typeof abilitiesData.learnedAbilities[0] === 'object') {
              const learnedAbility = abilitiesData.learnedAbilities.find(ability =>
                ability.id === room.requiredAbility
              );
              isLearned = learnedAbility && learnedAbility.currentLevel > 0;
            }
          }

          console.log(`Looking for ability: ${room.requiredAbility}`);
          console.log(`Is learned: ${isLearned}`);

          if (isLearned) {
            console.log(`✅ Room ${room.name} - ability found and learned`);
          } else {
            console.log(`❌ Room ${room.name} - ability not learned or not found`);
          }

          return isLearned;
        }

        // Если нет данных о способностях, показываем все комнаты
        console.log(`⚠️ No abilities data, showing room ${room.name}`);
        return true;
      });

      console.log('=== FILTERING COMPLETE ===');
      console.log(`Filtered rooms: ${filteredRooms.length}/${availableRooms.length}`);
      filteredRooms.forEach(room => console.log(`- ${room.name}`));
      
      console.log('[HTML] Available rooms:', availableRooms.length, 'Filtered rooms:', filteredRooms.length);
      
      // Helper function to get ability name by ID
      function getAbilityName(abilityId) {
        const abilityNames = {
          'bunk_storage': 'Хранилище',
          'bunk_elevator': 'Лифт',
          'bunk_armory': 'Оружейная',
          'bunk_server': 'Серверная',
          'bunk_market': 'Рынок',
          'bunk_classroom': 'Классная комната'
        };
        return abilityNames[abilityId] || abilityId;
      }
      
      // Отладочные логи закомментированы для продакшена
      /*
      console.log('=== TEMPORARY DEBUG: Showing all rooms ===');
      availableRooms.forEach(room => console.log(`Room: ${room.name}, Required: ${room.requiredAbility}`));
      */

      // Use filtered rooms for now, but we can switch to availableRooms for testing
      const roomsToShow = filteredRooms; // Change to availableRooms to show all

      // Create room option elements
      roomsToShow.forEach(room => {
        const roomOption = document.createElement('div');
        roomOption.className = 'room-option';
        roomOption.dataset.roomId = room.id;
        
        // Добавляем классы для разных категорий комнат
        if (room.category === 'critical') {
          roomOption.classList.add('critical-room');
        } else if (room.category === 'advanced') {
          roomOption.classList.add('advanced-room');
        }
        
        // Определяем, заблокирована ли комната
        let isLocked = false;

        if (room.requiredAbility) {
          if (abilitiesData && abilitiesData.learnedAbilities) {
            // Проверяем, есть ли способность в массиве изученных
            if (Array.isArray(abilitiesData.learnedAbilities)) {
              if (typeof abilitiesData.learnedAbilities[0] === 'string') {
                // Если массив содержит строки
                isLocked = !abilitiesData.learnedAbilities.includes(room.requiredAbility);
              } else if (typeof abilitiesData.learnedAbilities[0] === 'object') {
                // Если массив содержит объекты
                isLocked = !abilitiesData.learnedAbilities.find(ability =>
                  ability.id === room.requiredAbility && ability.currentLevel > 0
                );
              }
            } else {
              isLocked = true; // Если нет данных о способностях
            }
          } else {
            isLocked = true; // Если нет данных о способностях
          }
        }

        // Отладочный лог закомментирован для продакшена
        // console.log(`[HTML] Room ${room.name}, required: ${room.requiredAbility}, isLocked: ${isLocked}`);

        if (isLocked) {
          roomOption.classList.add('locked-room');
        } else {
          roomOption.classList.add('unlocked-room');
        }
        
        roomOption.innerHTML = `
          <div class="room-icon">${room.icon}</div>
          <div class="room-name">${room.name}</div>
          <div class="room-description">${room.description}</div>
          <div class="room-cost">${room.cost}</div>
          ${room.requiredAbility ? `<div class="room-requirement">Требует: ${getAbilityName(room.requiredAbility)}</div>` : ''}
        `;

        // Add both click and touch handlers with protection against accidental clicks
        const handleRoomSelect = (event) => {
          // Дополнительная защита: проверяем, не было ли недавно открыто модальное окно
          const now = Date.now();
          const lastOpenTime = window.lastRoomModalOpenTime || 0;
          if (now - lastOpenTime < 200) { // 200мс после открытия модального окна
            console.log('[HTML] Modal just opened, ignoring room selection');
            return;
          }
          
          // Проверяем, не является ли это скроллом
          if (event.type === 'touchend' && event.changedTouches && event.changedTouches.length > 0) {
            const touch = event.changedTouches[0];
            const startX = roomOption.dataset.touchStartX;
            const startY = roomOption.dataset.touchStartY;
            
            // Если есть начальная позиция касания, проверяем расстояние
            if (startX && startY) {
              const dx = Math.abs(touch.clientX - parseInt(startX));
              const dy = Math.abs(touch.clientY - parseInt(startY));
              
              // Если движение больше 10px, считаем это скроллом, а не выбором
              if (dx > 10 || dy > 10) {
                console.log('[HTML] Scrolling detected, ignoring room selection');
                return;
              }
            }
          }
          
          // Предотвращаем всплытие события
          event.preventDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
          
          console.log('[HTML] Room selected:', room.id, room.name);

          // Проверяем, заблокирована ли комната
          if (roomOption.classList.contains('locked-room')) {
            console.log('[HTML] Room is locked, cannot select');
            // Показываем уведомление пользователю
            alert(`Комната "${room.name}" заблокирована. Требуется способность: ${getAbilityName(room.requiredAbility)}`);
            return;
          }

          // Проверяем, разблокирована ли комната
          if (!roomOption.classList.contains('unlocked-room') && room.requiredAbility) {
            console.log('[HTML] Room is not unlocked, cannot select');
            alert(`Комната "${room.name}" недоступна. Требуется способность: ${getAbilityName(room.requiredAbility)}`);
            return;
          }
          
          // Remove previous selection
          document.querySelectorAll('.room-option').forEach(opt => opt.classList.remove('selected'));
          
          // Select this room
          roomOption.classList.add('selected');
          
          // Call game scene to handle room placement
          const gameScene = window.currentGameScene;
          console.log('[HTML] Attempting to use gameScene:', !!gameScene);
          console.log('[HTML] window.currentGameScene exists:', !!window.currentGameScene);
          
          if (gameScene) {
            console.log('[HTML] GameScene found:', !!gameScene);
            console.log('[HTML] simpleBunker exists:', !!gameScene.simpleBunker);
            
            // Передаем выбранный тип комнаты в bunkerView
            if (gameScene.simpleBunker && typeof gameScene.simpleBunker.setSelectedRoomType === 'function') {
              console.log('[HTML] Calling setSelectedRoomType with:', room.id);
              gameScene.simpleBunker.setSelectedRoomType(room.id);
            } else {
              console.warn('[HTML] simpleBunker or setSelectedRoomType not available');
            }
            
            // Также вызываем оригинальный метод для совместимости
            if (typeof gameScene.selectRoomTypeForPlacement === 'function') {
              console.log('[HTML] Calling selectRoomTypeForPlacement with:', room.id);
              gameScene.selectRoomTypeForPlacement(room.id);
            } else {
              console.warn('[HTML] selectRoomTypeForPlacement not available');
            }
          } else {
            console.error('[HTML] GameScene not available in currentGameScene');
            console.log('[HTML] Available window properties:', Object.keys(window).filter(k => k.includes('game')));
          }
          
          // Close the modal
          closeModal('room-selection-modal');
        };

        // Привязываем обработчики событий для кликов и касаний
        roomOption.addEventListener('click', handleRoomSelect);
        roomOption.addEventListener('touchstart', (event) => {
          // Сохраняем начальную позицию касания для определения скролла
          if (event.touches && event.touches.length > 0) {
            const touch = event.touches[0];
            roomOption.dataset.touchStartX = touch.clientX.toString();
            roomOption.dataset.touchStartY = touch.clientY.toString();
          }
        });
        roomOption.addEventListener('touchend', handleRoomSelect);

        roomSelectionGrid.appendChild(roomOption);
      });
    };

    function setupCategoryTabs() {
      const tabs = document.querySelectorAll('.category-tab');
      
      // Remove existing event listeners to prevent duplicates
      tabs.forEach(tab => {
        const newTab = tab.cloneNode(true);
        tab.parentNode.replaceChild(newTab, tab);
      });
      
      // Add new event listeners
      document.querySelectorAll('.category-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          currentCategory = tab.dataset.category;
          
          // Clear any visible tooltips before rendering
          const tooltips = document.querySelectorAll('.ability-tooltip');
          tooltips.forEach(tooltip => {
            tooltip.remove();
          });
          
          renderAbilityTree();
        });
      });
    }

    function renderAbilityTree() {
      const tree = document.getElementById('ability-tree');
      if (!tree) return;

      // Clear existing content
      tree.innerHTML = '<svg class="connection-lines" id="connection-lines"></svg>';

      // Clear any visible tooltips
      const tooltips = document.querySelectorAll('.ability-tooltip');
      tooltips.forEach(tooltip => {
        tooltip.remove();
      });

      // Обновляем модальное окно выбора комнат после изменения способностей
      if (typeof window.updateRoomSelectionModal === 'function') {
        console.log('[HTML] Updating room selection modal after ability tree render');
        setTimeout(() => window.updateRoomSelectionModal(), 100);
      }

      // Обновляем видимость кнопки удаления комнат в Phaser
      if (window.game && window.game.scene) {
        const gameScene = window.game.scene.getScene('Game');
        if (gameScene && gameScene.simpleBunker && typeof gameScene.simpleBunker.updateRemoveButtonVisibility === 'function') {
          console.log('[HTML] Updating remove button visibility after ability change');
          setTimeout(() => gameScene.simpleBunker.updateRemoveButtonVisibility(), 200);
        }
      }
      
      const connections = document.getElementById('connection-lines');
      if (!connections) return;

      const categoryAbilities = abilitiesData[currentCategory] || [];
      
      // Render ability nodes
      categoryAbilities.forEach(ability => {
        const node = createAbilityNode(ability);
        tree.appendChild(node);
      });

      // Render connection lines
      renderConnections(categoryAbilities);
    }

    function createAbilityNode(ability) {
      const node = document.createElement('div');
      node.className = 'ability-node';
      node.dataset.abilityId = ability.id;
      
      // Determine node state
      if (ability.currentLevel >= ability.maxLevel) {
        node.classList.add('maxed');
      } else if (ability.currentLevel > 0) {
        node.classList.add('learned');
      } else if (canLearnAbility(ability)) {
        node.classList.add('unlocked');
      } else {
        node.classList.add('locked');
      }

      // Set position
      node.style.left = ability.position.x + 'px';
      node.style.top = ability.position.y + 'px';

      // Set content
      const bonusText = getBonusText(ability);
      node.innerHTML = `
        <div class="name">${ability.name}</div>
        <div class="description">${ability.description}</div>
        ${bonusText ? `<div class="bonus ${ability.currentLevel > 0 ? 'current' : ''}">${bonusText}</div>` : ''}
        ${ability.currentLevel > 0 ? `<div class="level">${ability.currentLevel}</div>` : ''}
      `;

      // Add event listeners
      node.addEventListener('click', () => handleAbilityClick(ability));
      node.addEventListener('mouseenter', (e) => showAbilityTooltip(e, ability));
      node.addEventListener('mouseleave', hideAbilityTooltip);

      return node;
    }

    function renderConnections(abilities) {
      const connections = document.getElementById('connection-lines');
      
      abilities.forEach(ability => {
        ability.requirements.forEach(reqId => {
          const reqAbility = abilities.find(a => a.id === reqId);
          if (reqAbility) {
            const line = createConnectionLine(ability, reqAbility);
            connections.appendChild(line);
          }
        });
      });
    }

    function createConnectionLine(from, to) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      const fromX = from.position.x + 60; // Center of the node (120px width / 2)
      const fromY = from.position.y + 40; // Center of the node (80px height / 2)
      const toX = to.position.x + 60;
      const toY = to.position.y + 40;

      line.setAttribute('x1', fromX);
      line.setAttribute('y1', fromY);
      line.setAttribute('x2', toX);
      line.setAttribute('y2', toY);
      line.setAttribute('class', 'connection-line');

      // Determine line state
      if (from.currentLevel > 0 && to.currentLevel > 0) {
        line.classList.add('learned');
      } else if (canLearnAbility(from) && canLearnAbility(to)) {
        line.classList.add('unlocked');
      }

      return line;
    }

    function canLearnAbility(ability) {
      // Check if all requirements are met
      const requirementsMet = ability.requirements.every(reqId => {
        const reqAbility = findAbilityById(reqId);
        return reqAbility && reqAbility.currentLevel > 0;
      });

      // Check if we have enough points
      const canAfford = currentAbilityPoints >= ability.cost;

      // Check if not maxed out
      const notMaxed = ability.currentLevel < ability.maxLevel;

      return requirementsMet && canAfford && notMaxed;
    }

    function findAbilityById(id) {
      for (const category of Object.values(abilitiesData)) {
        const ability = category.find(a => a.id === id);
        if (ability) return ability;
      }
      return null;
    }

    function getBonusText(ability) {
      if (ability.currentLevel === 0) return null;
      
      const totalBonus = ability.currentLevel * getAbilityBonusPerLevel(ability);
      const maxBonus = ability.maxLevel * getAbilityBonusPerLevel(ability);
      
      if (ability.maxLevel === 1) {
        return `+${totalBonus}`;
      } else {
        return `+${totalBonus}/${maxBonus}`;
      }
    }

    function getAbilityBonusPerLevel(ability) {
      // Возвращает бонус за один уровень способности
      switch (ability.id) {
        case 'res_cooking':
          return 1; // +1 еда за уровень
        case 'res_plumbing':
          return 1; // +1 вода за уровень
        case 'res_hunting':
          return 5; // +5% еды за уровень
        case 'res_scouting':
          return 5; // +5% добычи за уровень
        case 'res_science':
          return 1; // +1 опыт за уровень
        case 'res_chemistry':
          return 1; // +1 опыт за уровень
        case 'res_market_economy':
          return 1; // +1 деньги за уровень
        case 'res_penicillin':
          return 1; // +1 здоровье за уровень
          
        // Бункер способности
        case 'bunk_fast_building':
          return 5; // +5% скорость строительства за уровень
        case 'bunk_building_discount':
          return 5; // +5% скидка на строительство за уровень
        case 'bunk_energy_storage':
          return 1; // +1 комната для питания за уровень
          
        // Защита способности
        case 'def_armor':
          return 5; // +5 ед. здоровья стен за уровень
        case 'def_repair':
          return 1; // +1 ед./час восстановления за уровень
        case 'def_damage_boost':
          return 1; // +1 ед. урона за уровень
        case 'def_army':
          return 5; // +5% экономии патронов для солдат за уровень
        case 'def_misfire':
          return 5; // +5% шанс осечки за уровень
          
        // Разное способности
        case 'misc_skill_points':
          return 1; // +1 очко способностей за уровень
        case 'misc_night_speed':
          return 5; // +5% ускорение ночи за уровень
        case 'misc_day_speed':
          return 5; // +5% ускорение дня за уровень
        default:
          return 1; // По умолчанию +1
      }
    }

    function handleAbilityClick(ability) {
      if (!canLearnAbility(ability)) {
        if (ability.currentLevel >= ability.maxLevel) {
          showToast('Способность уже максимально изучена!');
        } else if (ability.currentLevel > 0) {
          showToast('Недостаточно очков для улучшения!');
        } else {
          showToast('Требования не выполнены!');
        }
        return;
      }

      // Learn/upgrade ability
      currentAbilityPoints -= ability.cost;
      ability.currentLevel++;
      learnedAbilities.add(ability.id);

      // Update UI
      updateAbilityPoints();
      renderAbilityTree();

      showToast(`Изучена способность: ${ability.name} (уровень ${ability.currentLevel})`);
    }

    function showAbilityTooltip(event, ability) {
      const tooltip = document.createElement('div');
      tooltip.className = 'ability-tooltip';
      
      const bonusText = getBonusText(ability);
      const bonusInfo = bonusText ? `<div class="cost">Текущий бонус: ${bonusText}</div>` : '';
      
      tooltip.innerHTML = `
        <h4>${ability.name}</h4>
        <div class="description">${ability.description}</div>
        <div class="cost">Стоимость: ${ability.cost} очков</div>
        <div class="cost">Уровень: ${ability.currentLevel}/${ability.maxLevel}</div>
        ${bonusInfo}
        ${ability.requirements.length > 0 ? 
          `<div class="requirements">Требования: ${ability.requirements.map(id => findAbilityById(id)?.name).join(', ')}</div>` : 
          '<div class="requirements">Без требований</div>'
        }
      `;

      // Position tooltip relative to cursor
      const rect = event.target.getBoundingClientRect();
      const tooltipWidth = 250;
      const tooltipHeight = 150;
      
      // Calculate position to ensure tooltip is visible
      let left = rect.right + 10;
      let top = rect.top - 10;
      
      // Check if tooltip would go off the right edge
      if (left + tooltipWidth > window.innerWidth) {
        left = rect.left - tooltipWidth - 10;
      }
      
      // Check if tooltip would go off the bottom edge
      if (top + tooltipHeight > window.innerHeight) {
        top = window.innerHeight - tooltipHeight - 10;
      }
      
      // Ensure tooltip doesn't go off the left or top edges
      left = Math.max(10, left);
      top = Math.max(10, top);
      
      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';

      document.body.appendChild(tooltip);
      
      // Show tooltip
      setTimeout(() => tooltip.classList.add('show'), 100);
      
      // Store reference for removal
      event.target.tooltip = tooltip;
    }

    function hideAbilityTooltip(event) {
      if (event.target.tooltip) {
        event.target.tooltip.remove();
        event.target.tooltip = null;
      }
    }

    function updateAbilityPoints() {
      const pointsElement = document.getElementById('ability-points');
      if (pointsElement) {
        pointsElement.textContent = currentAbilityPoints;
      }
    }

    function clearAbilityTree() {
      const tree = document.getElementById('ability-tree');
      if (tree) {
        tree.innerHTML = '<svg class="connection-lines" id="connection-lines"></svg>';
      }
      
      // Clear all visible tooltips
      clearAllTooltips();
    }

    function clearAllTooltips() {
      const tooltips = document.querySelectorAll('.ability-tooltip');
      tooltips.forEach(tooltip => {
        tooltip.remove();
      });
    }

    function showToast(message) {
      // Simple toast implementation
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--bunker-gold);
        color: var(--bunker-bg);
        padding: 10px 15px;
        border-radius: 4px;
        z-index: 10000;
        font-size: 12px;
        max-width: 300px;
      `;
      toast.textContent = message;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    // Функция для получения данных о способностях (для синхронизации с Phaser)
    window.getAbilitiesData = function() {
      return {
        currentPoints: currentAbilityPoints,
        learnedAbilities: Array.from(learnedAbilities),
        abilitiesData: abilitiesData
      };
    };

    // Функция для установки данных о способностях (для синхронизации с Phaser)
    window.setAbilitiesData = function(data) {
      if (data.currentPoints !== undefined) {
        currentAbilityPoints = data.currentPoints;
      }
      if (data.learnedAbilities) {
        learnedAbilities = new Set(data.learnedAbilities);
      }
      if (data.abilitiesData) {
        abilitiesData = data.abilitiesData;
      }
      
      // Обновляем UI
      updateAbilityPoints();
      renderAbilityTree();
    };

    // Universal resource click handler
    window.handleResourceClick = function(resourceType) {
      console.log('Resource clicked:', resourceType);

      // Add visual feedback
      const clickedElement = event?.target;
      if (clickedElement) {
        clickedElement.style.transform = 'scale(0.95)';
        setTimeout(() => {
          clickedElement.style.transform = '';
        }, 100);
      }

      if (resourceType === 'residents') {
        window.openResidents();
      } else if (resourceType === 'enemies') {
        window.openEnemies();
      } else {
        window.openResource(resourceType);
      }
    };

    // Debug functions for testing
    window.debugOpenPopulation = function() {
      console.log('Debug: Opening population modal');
      window.openResidents();
    };

    window.debugOpenHappiness = function() {
      console.log('Debug: Opening happiness modal');
      window.openResource('happiness');
    };

    window.debugOpenInventory = function() {
      console.log('Debug: Opening inventory modal');
      window.openInventory();
    };

    // Функции для переключения между видами в модальном окне населения
    window.showResidentDetail = function() {
      console.log('[showResidentDetail] Switching to resident detail view');
      
      // Скрываем список жителей
      const listView = document.getElementById('population-list-view');
      if (listView) {
        listView.style.display = 'none';
      }
      
      // Показываем подробности жителя
      const detailView = document.getElementById('resident-detail-view');
      if (detailView) {
        detailView.style.display = 'block';
        // Добавляем небольшую задержку для плавной анимации
        setTimeout(() => {
          detailView.classList.add('active');
        }, 10);
      }
      
      // Обновляем заголовок модального окна
      const title = document.getElementById('population-modal-title');
      if (title) {
        title.textContent = 'ПОДРОБНОСТИ О ЖИТЕЛЕ';
      }
    };

    window.showPopulationList = function() {
      console.log('[showPopulationList] Switching back to population list view');
      
      // Скрываем подробности жителя
      const detailView = document.getElementById('resident-detail-view');
      if (detailView) {
        detailView.classList.remove('active');
        setTimeout(() => {
          detailView.style.display = 'none';
        }, 300); // Ждем окончания анимации
      }
      
      // Показываем список жителей
      const listView = document.getElementById('population-list-view');
      if (listView) {
        listView.style.display = 'block';
      }
      
      // Возвращаем оригинальный заголовок
      const title = document.getElementById('population-modal-title');
      if (title) {
        title.textContent = 'РЕЕСТР ВЫЖИВШИХ';
      }
    };

    // Функция для раскрытия скрытых навыков при клике
    window.revealHiddenSkill = function(element, skillIndex) {
      console.log(`[revealHiddenSkill] Revealing skill at index: ${skillIndex}`);
      
      // Получаем данные о жителе
      const resident = window.currentResidentsData ? window.currentResidentsData[window.currentResidentIndex] : null;
      if (!resident || !resident.skills || !resident.skills[skillIndex]) {
        console.warn('[revealHiddenSkill] Resident or skill data not available');
        return;
      }
      
      const skill = resident.skills[skillIndex];
      console.log(`[revealHiddenSkill] Skill data:`, skill);
      
      // Раскрываем навык - показываем название и окрашиваем по контексту
      element.classList.remove('hidden-skill');
      element.classList.add(skill.positive ? 'positive' : 'negative');
      
      // Обновляем содержимое
      const skillText = element.querySelector('.skill-text');
      const skillEffect = element.querySelector('.skill-effect');
      
      if (skillText) {
        skillText.textContent = skill.text;
      }
      
      if (skillEffect) {
        skillEffect.textContent = skill.positive ? '✓' : '✗';
      }
      
      // Убираем обработчик клика, так как навык уже раскрыт
      element.onclick = null;
      
      console.log(`[revealHiddenSkill] Skill "${skill.text}" revealed successfully`);
    };
  </script>

</html>


